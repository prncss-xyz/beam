{
  "files": {
    "src/lib/transducers/core.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "0",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(24,17): error TS2534: A function returning 'never' cannot have a reachable end point.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 26
            },
            "start": {
              "column": 23,
              "line": 24
            }
          }
        },
        {
          "id": "1",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(34,4): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 62
            },
            "start": {
              "column": 6,
              "line": 34
            }
          }
        },
        {
          "id": "2",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 35
            },
            "start": {
              "column": 15,
              "line": 35
            }
          }
        },
        {
          "id": "3",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [ 1, 3, 5 ] to deeply equal [ 1, 3 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "6"
          ],
          "coveredBy": [
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 38
            },
            "start": {
              "column": 20,
              "line": 36
            }
          }
        },
        {
          "id": "4",
          "mutatorName": "BooleanLiteral",
          "replacement": "true",
          "statusReason": "expected [ 1, 3, 5 ] to deeply equal [ 1, 3 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "6"
          ],
          "coveredBy": [
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 18,
              "line": 37
            },
            "start": {
              "column": 13,
              "line": 37
            }
          }
        },
        {
          "id": "5",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(39,18): error TS2345: Argument of type '{}' is not assignable to parameter of type 'Ctx<A, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 45
            },
            "start": {
              "column": 18,
              "line": 39
            }
          }
        },
        {
          "id": "6",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(53,5): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 15,
              "line": 49
            },
            "start": {
              "column": 10,
              "line": 49
            }
          }
        },
        {
          "id": "7",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "status": "Timeout",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 60
            },
            "start": {
              "column": 17,
              "line": 49
            }
          }
        },
        {
          "id": "8",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "src/lib/transducers/core.ts(53,5): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 51
            },
            "start": {
              "column": 9,
              "line": 51
            }
          }
        },
        {
          "id": "9",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(53,5): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 51
            },
            "start": {
              "column": 9,
              "line": 51
            }
          }
        },
        {
          "id": "10",
          "mutatorName": "EqualityOperator",
          "replacement": "r !== undefined",
          "statusReason": "src/lib/transducers/core.ts(53,5): error TS2488: Type 'undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 51
            },
            "start": {
              "column": 9,
              "line": 51
            }
          }
        },
        {
          "id": "11",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 56
            },
            "start": {
              "column": 9,
              "line": 54
            }
          }
        },
        {
          "id": "12",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 59
            },
            "start": {
              "column": 21,
              "line": 56
            }
          }
        },
        {
          "id": "13",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "An error occurred outside of a test run, please be sure to properly await your promises! {\"type\":\"Unhandled Error\",\"stacks\":[]}",
          "status": "RuntimeError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 30,
              "line": 57
            },
            "start": {
              "column": 11,
              "line": 57
            }
          }
        },
        {
          "id": "14",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 30,
              "line": 57
            },
            "start": {
              "column": 11,
              "line": 57
            }
          }
        },
        {
          "id": "15",
          "mutatorName": "EqualityOperator",
          "replacement": "value === cutSymbol",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "6",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 30,
              "line": 57
            },
            "start": {
              "column": 11,
              "line": 57
            }
          }
        },
        {
          "id": "16",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(44,5): error TS2322: Type '<B, N, P, Q>(op: Op<B[], B, N>, init: Q, coll: ICollection<P, Q, N>) => void' is not assignable to type '<C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>'.\n  Type 'void' is not assignable to type '() => IteratorResult<C, any>'.\nsrc/lib/transducers/reducers.test.ts(38,23): error TS2488: Type '{ next: void; [Symbol.iterator](): ...; }' must have a '[Symbol.iterator]()' method that returns an iterator.\nsrc/lib/transducers/utils.test.ts(11,23): error TS2488: Type '{ next: void; [Symbol.iterator](): ...; }' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 116
            },
            "start": {
              "column": 3,
              "line": 68
            }
          }
        },
        {
          "id": "17",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "42"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 69
            },
            "start": {
              "column": 15,
              "line": 69
            }
          }
        },
        {
          "id": "18",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 4,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "1",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 72
            },
            "start": {
              "column": 20,
              "line": 70
            }
          }
        },
        {
          "id": "19",
          "mutatorName": "BooleanLiteral",
          "replacement": "true",
          "statusReason": "expected [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 4,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "1",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 18,
              "line": 71
            },
            "start": {
              "column": 13,
              "line": 71
            }
          }
        },
        {
          "id": "20",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(78,18): error TS2345: Argument of type '{}' is not assignable to parameter of type 'Ctx<B[], B>'.\n  Type '{}' is missing the following properties from type 'Ctx<B[], B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 84
            },
            "start": {
              "column": 18,
              "line": 78
            }
          }
        },
        {
          "id": "21",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(88,27): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 115
            },
            "start": {
              "column": 45,
              "line": 88
            }
          }
        },
        {
          "id": "22",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(100,7): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 89
            },
            "start": {
              "column": 12,
              "line": 89
            }
          }
        },
        {
          "id": "23",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "Hit limit reached (3501/3500)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 108
            },
            "start": {
              "column": 19,
              "line": 89
            }
          }
        },
        {
          "id": "24",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "src/lib/transducers/core.ts(100,7): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 25,
              "line": 90
            },
            "start": {
              "column": 11,
              "line": 90
            }
          }
        },
        {
          "id": "25",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "42"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 25,
              "line": 90
            },
            "start": {
              "column": 11,
              "line": 90
            }
          }
        },
        {
          "id": "26",
          "mutatorName": "EqualityOperator",
          "replacement": "acc.length >= 0",
          "statusReason": "Hit limit reached (3501/3500)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 25,
              "line": 90
            },
            "start": {
              "column": 11,
              "line": 90
            }
          }
        },
        {
          "id": "27",
          "mutatorName": "EqualityOperator",
          "replacement": "acc.length <= 0",
          "statusReason": "Hit limit reached (3501/3500)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 25,
              "line": 90
            },
            "start": {
              "column": 11,
              "line": 90
            }
          }
        },
        {
          "id": "28",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "42"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 93
            },
            "start": {
              "column": 27,
              "line": 90
            }
          }
        },
        {
          "id": "29",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(92,9): error TS2322: Type '{}' is not assignable to type 'IteratorResult<B, any>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 43,
              "line": 92
            },
            "start": {
              "column": 16,
              "line": 92
            }
          }
        },
        {
          "id": "30",
          "mutatorName": "BooleanLiteral",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "42"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 29,
              "line": 92
            },
            "start": {
              "column": 24,
              "line": 92
            }
          }
        },
        {
          "id": "31",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "src/lib/transducers/core.ts(100,7): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 95
            },
            "start": {
              "column": 11,
              "line": 95
            }
          }
        },
        {
          "id": "32",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(100,7): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 95
            },
            "start": {
              "column": 11,
              "line": 95
            }
          }
        },
        {
          "id": "33",
          "mutatorName": "EqualityOperator",
          "replacement": "r !== undefined",
          "statusReason": "src/lib/transducers/core.ts(100,7): error TS2488: Type 'undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 95
            },
            "start": {
              "column": 11,
              "line": 95
            }
          }
        },
        {
          "id": "34",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(97,7): error TS2488: Type 'readonly [P, N] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "23",
            "42"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 98
            },
            "start": {
              "column": 28,
              "line": 95
            }
          }
        },
        {
          "id": "35",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(97,9): error TS2322: Type '{}' is not assignable to type 'IteratorResult<B, any>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "23",
            "42"
          ],
          "location": {
            "end": {
              "column": 48,
              "line": 97
            },
            "start": {
              "column": 16,
              "line": 97
            }
          }
        },
        {
          "id": "36",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(97,9): error TS2322: Type '{ done: false; value: undefined; }' is not assignable to type 'IteratorResult<B, any>'.\n  Types of property 'value' are incompatible.\n    Type 'undefined' is not assignable to type 'B'.\n      'B' could be instantiated with an arbitrary type which could be unrelated to 'undefined'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "23",
            "42"
          ],
          "location": {
            "end": {
              "column": 28,
              "line": 97
            },
            "start": {
              "column": 24,
              "line": 97
            }
          }
        },
        {
          "id": "37",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "42"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25",
            "42"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 103
            },
            "start": {
              "column": 11,
              "line": 101
            }
          }
        },
        {
          "id": "38",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "25"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 107
            },
            "start": {
              "column": 23,
              "line": 103
            }
          }
        },
        {
          "id": "39",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "An error occurred outside of a test run, please be sure to properly await your promises! {\"type\":\"Unhandled Error\",\"stacks\":[]}",
          "status": "RuntimeError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "25"
          ],
          "location": {
            "end": {
              "column": 32,
              "line": 104
            },
            "start": {
              "column": 13,
              "line": 104
            }
          }
        },
        {
          "id": "40",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "25"
          ],
          "location": {
            "end": {
              "column": 32,
              "line": 104
            },
            "start": {
              "column": 13,
              "line": 104
            }
          }
        },
        {
          "id": "41",
          "mutatorName": "EqualityOperator",
          "replacement": "value === cutSymbol",
          "statusReason": "An error occurred outside of a test run, please be sure to properly await your promises! {\"type\":\"Unhandled Error\",\"stacks\":[]}",
          "status": "RuntimeError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "25"
          ],
          "location": {
            "end": {
              "column": 32,
              "line": 104
            },
            "start": {
              "column": 13,
              "line": 104
            }
          }
        },
        {
          "id": "42",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(106,9): error TS2322: Type '{}' is not assignable to type 'IteratorResult<B, any>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "25"
          ],
          "location": {
            "end": {
              "column": 48,
              "line": 106
            },
            "start": {
              "column": 16,
              "line": 106
            }
          }
        },
        {
          "id": "43",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(106,9): error TS2322: Type '{ done: false; value: undefined; }' is not assignable to type 'IteratorResult<B, any>'.\n  Types of property 'value' are incompatible.\n    Type 'undefined' is not assignable to type 'B'.\n      'B' could be instantiated with an arbitrary type which could be unrelated to 'undefined'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "25"
          ],
          "location": {
            "end": {
              "column": 28,
              "line": 106
            },
            "start": {
              "column": 24,
              "line": 106
            }
          }
        },
        {
          "id": "44",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ [ 1, 4 ], [ 2, undefined ], …(1) ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 23,
              "line": 109
            },
            "start": {
              "column": 9,
              "line": 109
            }
          }
        },
        {
          "id": "45",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 23,
              "line": 109
            },
            "start": {
              "column": 9,
              "line": 109
            }
          }
        },
        {
          "id": "46",
          "mutatorName": "EqualityOperator",
          "replacement": "acc.length >= 0",
          "statusReason": "expected [ [ 1, 4 ], [ 2, undefined ], …(1) ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 23,
              "line": 109
            },
            "start": {
              "column": 9,
              "line": 109
            }
          }
        },
        {
          "id": "47",
          "mutatorName": "EqualityOperator",
          "replacement": "acc.length <= 0",
          "statusReason": "expected [] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 23,
              "line": 109
            },
            "start": {
              "column": 9,
              "line": 109
            }
          }
        },
        {
          "id": "48",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 112
            },
            "start": {
              "column": 25,
              "line": 109
            }
          }
        },
        {
          "id": "49",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(111,7): error TS2322: Type '{}' is not assignable to type 'IteratorResult<B, any>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 111
            },
            "start": {
              "column": 14,
              "line": 111
            }
          }
        },
        {
          "id": "50",
          "mutatorName": "BooleanLiteral",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 27,
              "line": 111
            },
            "start": {
              "column": 22,
              "line": 111
            }
          }
        },
        {
          "id": "51",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(114,5): error TS2322: Type '{}' is not assignable to type 'IteratorResult<B, any>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 44,
              "line": 114
            },
            "start": {
              "column": 12,
              "line": 114
            }
          }
        },
        {
          "id": "52",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "src/lib/transducers/core.ts(114,5): error TS2322: Type '{ done: false; value: undefined; }' is not assignable to type 'IteratorResult<B, any>'.\n  Types of property 'value' are incompatible.\n    Type 'undefined' is not assignable to type 'B'.\n      'B' could be instantiated with an arbitrary type which could be unrelated to 'undefined'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 114
            },
            "start": {
              "column": 20,
              "line": 114
            }
          }
        },
        {
          "id": "53",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(61,20): error TS2558: Expected 0 type arguments, but got 3.\nsrc/lib/transducers/transformers.ts(104,20): error TS2558: Expected 0 type arguments, but got 3.\nsrc/lib/transducers/transformers.ts(131,22): error TS2558: Expected 0 type arguments, but got 3.\nsrc/lib/transducers/transformers.ts(155,22): error TS2558: Expected 0 type arguments, but got 3.\nsrc/lib/transducers/reducers.test.ts(33,9): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(54,9): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(71,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(71,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(76,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(76,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(82,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(82,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(91,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(91,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(98,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(98,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(104,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(104,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(110,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(110,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(114,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(114,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(122,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(122,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(128,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(128,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(137,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(137,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(147,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(147,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(156,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(156,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(166,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(166,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(172,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(172,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(175,37): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, Iterable<unknown>, number>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'readonly [() => IteratorResult<unknown, any>, unknown] | undefined' is not assignable to type 'readonly [any, number] | undefined'.\n      Type 'readonly [() => IteratorResult<unknown, any>, unknown]' is not assignable to type 'readonly [any, number]'.\n        Type at position 1 in source is not compatible with type at position 1 in target.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/reducers.test.ts(179,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(179,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(186,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(186,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(203,20): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(203,20): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(205,17): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(210,20): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(210,20): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(221,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(221,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(232,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(232,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(242,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(242,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(252,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(252,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(259,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(259,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\n  Types of property 'unfold' are incompatible.\n    Type '(next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined' is not assignable to type '(unacc: any) => readonly [any, number] | undefined'.\nsrc/lib/transducers/transformers.test.ts(25,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(25,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(30,16): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(30,16): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(45,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(45,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(51,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(51,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(55,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(55,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(61,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(61,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(65,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(65,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(71,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(71,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(75,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(75,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(79,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(79,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(85,17): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(85,17): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(93,11): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(97,19): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(97,19): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(101,19): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(101,19): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(109,18): error TS2532: Object is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(109,18): error TS2722: Cannot invoke an object which is possibly 'undefined'.\nsrc/lib/transducers/transformers.test.ts(117,7): error TS2722: Cannot invoke an object which is possibly 'undefined'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 124
            },
            "start": {
              "column": 3,
              "line": 119
            }
          }
        },
        {
          "id": "54",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(37,28): error TS2339: Property 'entries' does not exist on type 'void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "38",
            "39",
            "40",
            "41"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 124
            },
            "start": {
              "column": 56,
              "line": 120
            }
          }
        }
      ],
      "source": "import { Op } from \"./reducers\";\nimport { ICollection, IXForm, toArray } from \"./transformers\";\n\nexport interface Ctx<A, B> {\n  fold: (a: A, b: B) => A;\n  cut: () => never;\n  close: () => void;\n  step: <C, P, Q, N>(\n    op: Op<C[], C, N>,\n    init: Q,\n    coll: ICollection<P, Q, N>,\n  ) => () => IteratorResult<C>;\n  transform: <P, Q, N>(\n    op: Op<A, N, N>,\n    acc: A,\n    fold: (a: A, b: N) => A,\n    init: Q,\n    coll: ICollection<P, Q, N>,\n  ) => A;\n}\n\nconst cutSymbol = Symbol(\"cut\");\n\nfunction cut(): never {\n  throw cutSymbol;\n}\n\nexport function transform<A, B, N, P, Q>(\n  op: Op<A, B, N>,\n  acc: A,\n  fold: (a: A, b: B) => A,\n  init: Q,\n  coll: ICollection<P, Q, N>,\n): A {\n  let alive = true;\n  function close() {\n    alive = false;\n  }\n  const ctx = op({\n    cut,\n    close,\n    fold,\n    transform,\n    step,\n  });\n  const fold_ = ctx.fold;\n  let unacc = coll.setup(init);\n  const unfold = coll.unfold;\n  while (alive) {\n    const r = unfold(unacc);\n    if (r === undefined) break;\n    let b;\n    [unacc, b] = r;\n    try {\n      acc = fold_(acc, b);\n    } catch (value) {\n      if (value !== cutSymbol) throw value;\n      close();\n    }\n  }\n  return acc;\n}\n\nexport function step<B, N, P, Q>(\n  op: Op<B[], B, N>,\n  init: Q,\n  coll: ICollection<P, Q, N>,\n) {\n  let alive = true;\n  function close() {\n    alive = false;\n  }\n\n  const form = toArray<B>();\n  let acc = form.init();\n  const fold = form.fold;\n\n  const ctx = op({\n    cut,\n    close,\n    fold,\n    transform,\n    step,\n  });\n  const fold_ = ctx.fold;\n  let unacc = coll.setup(init);\n  const unfold = coll.unfold;\n  return function next(): IteratorResult<B> {\n    while (alive) {\n      if (acc.length > 0) {\n        const res = acc.shift() as B;\n        return { done: false, value: res };\n      }\n      const r = unfold(unacc);\n      if (r === undefined) {\n        close();\n        return { done: true, value: undefined };\n      }\n      let b;\n      [unacc, b] = r;\n      try {\n        acc = fold_(acc, b);\n      } catch (value) {\n        if (value !== cutSymbol) throw value;\n        close();\n        return { done: true, value: undefined };\n      }\n    }\n    if (acc.length > 0) {\n      const res = acc.shift() as B;\n      return { done: false, value: res };\n    }\n    close();\n    return { done: true, value: undefined };\n  };\n}\n\nexport const transduce =\n  <P, Q, N>(coll: ICollection<P, Q, N>, init: Q) =>\n  <A, B, C>(form: IXForm<A, B, C>, op: Op<A, B, N>) => {\n    const acc = form.init();\n    const fold = form.fold;\n    return form.result(transform(op, acc, fold, init, coll));\n  };\n"
    },
    "src/lib/transducers/reducers.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "55",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(6,29): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 15
            },
            "start": {
              "column": 41,
              "line": 6
            }
          }
        },
        {
          "id": "56",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(7,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 14
            },
            "start": {
              "column": 25,
              "line": 7
            }
          }
        },
        {
          "id": "57",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(7,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 13
            },
            "start": {
              "column": 12,
              "line": 8
            }
          }
        },
        {
          "id": "58",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(7,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 12
            },
            "start": {
              "column": 29,
              "line": 10
            }
          }
        },
        {
          "id": "63",
          "mutatorName": "UpdateOperator",
          "replacement": "i--",
          "statusReason": "expected [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "24"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 12,
              "line": 23
            },
            "start": {
              "column": 9,
              "line": 23
            }
          }
        },
        {
          "id": "64",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 20,
              "line": 25
            },
            "start": {
              "column": 13,
              "line": 25
            }
          }
        },
        {
          "id": "65",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 20,
              "line": 25
            },
            "start": {
              "column": 13,
              "line": 25
            }
          }
        },
        {
          "id": "67",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(31,40): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 44
            },
            "start": {
              "column": 52,
              "line": 32
            }
          }
        },
        {
          "id": "68",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(32,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 43
            },
            "start": {
              "column": 25,
              "line": 33
            }
          }
        },
        {
          "id": "69",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(32,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 42
            },
            "start": {
              "column": 12,
              "line": 35
            }
          }
        },
        {
          "id": "70",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(32,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 8,
              "line": 41
            },
            "start": {
              "column": 29,
              "line": 37
            }
          }
        },
        {
          "id": "71",
          "mutatorName": "UpdateOperator",
          "replacement": "i--",
          "statusReason": "expected [] to deeply equal [ 'chair', 'goat' ]",
          "status": "Killed",
          "testsCompleted": 7,
          "static": true,
          "killedBy": [
            "5"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 12,
              "line": 38
            },
            "start": {
              "column": 9,
              "line": 38
            }
          }
        },
        {
          "id": "72",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ 'kayak', 'chair', 'goat' ] to deeply equal [ 'chair', 'goat' ]",
          "status": "Killed",
          "testsCompleted": 7,
          "static": true,
          "killedBy": [
            "5"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 39
            },
            "start": {
              "column": 13,
              "line": 39
            }
          }
        },
        {
          "id": "73",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ 'chair', 'goat' ]",
          "status": "Killed",
          "testsCompleted": 7,
          "static": true,
          "killedBy": [
            "5"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 39
            },
            "start": {
              "column": 13,
              "line": 39
            }
          }
        },
        {
          "id": "74",
          "mutatorName": "EqualityOperator",
          "replacement": "i >= n",
          "statusReason": "expected [ 'kayak', 'chair', 'goat' ] to deeply equal [ 'chair', 'goat' ]",
          "status": "Killed",
          "testsCompleted": 7,
          "static": true,
          "killedBy": [
            "5"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 39
            },
            "start": {
              "column": 13,
              "line": 39
            }
          }
        },
        {
          "id": "75",
          "mutatorName": "EqualityOperator",
          "replacement": "i <= n",
          "statusReason": "expected [ 'kayak' ] to deeply equal [ 'chair', 'goat' ]",
          "status": "Killed",
          "testsCompleted": 7,
          "static": true,
          "killedBy": [
            "5"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 39
            },
            "start": {
              "column": 13,
              "line": 39
            }
          }
        },
        {
          "id": "76",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(45,56): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "6",
            "25"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 56
            },
            "start": {
              "column": 68,
              "line": 46
            }
          }
        },
        {
          "id": "77",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(46,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "6",
            "25"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 55
            },
            "start": {
              "column": 25,
              "line": 47
            }
          }
        },
        {
          "id": "78",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(46,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "6",
            "25"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 54
            },
            "start": {
              "column": 12,
              "line": 48
            }
          }
        },
        {
          "id": "79",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(46,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "6",
            "25"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 53
            },
            "start": {
              "column": 29,
              "line": 50
            }
          }
        },
        {
          "id": "80",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "6",
            "25"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 51
            },
            "start": {
              "column": 13,
              "line": 51
            }
          }
        },
        {
          "id": "81",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "6",
            "25"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 51
            },
            "start": {
              "column": 13,
              "line": 51
            }
          }
        },
        {
          "id": "82",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(57,56): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 70
            },
            "start": {
              "column": 68,
              "line": 58
            }
          }
        },
        {
          "id": "83",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(58,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 69
            },
            "start": {
              "column": 25,
              "line": 59
            }
          }
        },
        {
          "id": "84",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "expected [ 1, 3, 4, 5 ] to deeply equal [ 4, 5 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "7"
          ],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 60
            },
            "start": {
              "column": 20,
              "line": 60
            }
          }
        },
        {
          "id": "85",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(58,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 68
            },
            "start": {
              "column": 12,
              "line": 61
            }
          }
        },
        {
          "id": "86",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(58,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 67
            },
            "start": {
              "column": 29,
              "line": 63
            }
          }
        },
        {
          "id": "87",
          "mutatorName": "AssignmentOperator",
          "replacement": "dropping ||= c(b)",
          "statusReason": "expected [] to deeply equal [ 4, 5 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "7"
          ],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 64
            },
            "start": {
              "column": 9,
              "line": 64
            }
          }
        },
        {
          "id": "88",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ 4, 5 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "7"
          ],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 65
            },
            "start": {
              "column": 13,
              "line": 65
            }
          }
        },
        {
          "id": "89",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [ 1, 3, 4, 5 ] to deeply equal [ 4, 5 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "7"
          ],
          "coveredBy": [
            "7"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 65
            },
            "start": {
              "column": 13,
              "line": 65
            }
          }
        },
        {
          "id": "90",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(71,51): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 83
            },
            "start": {
              "column": 63,
              "line": 72
            }
          }
        },
        {
          "id": "91",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(72,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 82
            },
            "start": {
              "column": 25,
              "line": 73
            }
          }
        },
        {
          "id": "92",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(72,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 81
            },
            "start": {
              "column": 12,
              "line": 74
            }
          }
        },
        {
          "id": "93",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(72,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 8,
              "line": 80
            },
            "start": {
              "column": 29,
              "line": 76
            }
          }
        },
        {
          "id": "94",
          "mutatorName": "BooleanLiteral",
          "replacement": "c(b)",
          "statusReason": "expected [ 'kayak' ] to deeply equal [ 'kayak', 'chair' ]",
          "status": "Killed",
          "testsCompleted": 6,
          "static": true,
          "killedBy": [
            "4"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 77
            },
            "start": {
              "column": 13,
              "line": 77
            }
          }
        },
        {
          "id": "95",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ 'kayak', 'chair', 'goat' ] to deeply equal [ 'kayak', 'chair' ]",
          "status": "Killed",
          "testsCompleted": 6,
          "static": true,
          "killedBy": [
            "4"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 77
            },
            "start": {
              "column": 13,
              "line": 77
            }
          }
        },
        {
          "id": "96",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [ 'kayak' ] to deeply equal [ 'kayak', 'chair' ]",
          "status": "Killed",
          "testsCompleted": 6,
          "static": true,
          "killedBy": [
            "4"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 77
            },
            "start": {
              "column": 13,
              "line": 77
            }
          }
        },
        {
          "id": "97",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(84,53): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 95
            },
            "start": {
              "column": 65,
              "line": 85
            }
          }
        },
        {
          "id": "98",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(85,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 94
            },
            "start": {
              "column": 25,
              "line": 86
            }
          }
        },
        {
          "id": "99",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(85,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 93
            },
            "start": {
              "column": 12,
              "line": 87
            }
          }
        },
        {
          "id": "100",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(85,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 8,
              "line": 92
            },
            "start": {
              "column": 29,
              "line": 89
            }
          }
        },
        {
          "id": "101",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ 1, 2, 3 ] to deeply equal [ 1, 3 ]",
          "status": "Killed",
          "testsCompleted": 12,
          "static": true,
          "killedBy": [
            "10"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 17,
              "line": 90
            },
            "start": {
              "column": 13,
              "line": 90
            }
          }
        },
        {
          "id": "102",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ 1, 3 ]",
          "status": "Killed",
          "testsCompleted": 12,
          "static": true,
          "killedBy": [
            "10"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 17,
              "line": 90
            },
            "start": {
              "column": 13,
              "line": 90
            }
          }
        },
        {
          "id": "103",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(96,60): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 107
            },
            "start": {
              "column": 72,
              "line": 97
            }
          }
        },
        {
          "id": "104",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(97,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 106
            },
            "start": {
              "column": 25,
              "line": 98
            }
          }
        },
        {
          "id": "105",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(97,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 105
            },
            "start": {
              "column": 12,
              "line": 99
            }
          }
        },
        {
          "id": "106",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(97,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 8,
              "line": 104
            },
            "start": {
              "column": 29,
              "line": 101
            }
          }
        },
        {
          "id": "107",
          "mutatorName": "BooleanLiteral",
          "replacement": "c(b)",
          "statusReason": "expected [ 2, 3, 2 ] to deeply equal [ 2, 2, 4 ]",
          "status": "Killed",
          "testsCompleted": 13,
          "static": true,
          "killedBy": [
            "11"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 102
            },
            "start": {
              "column": 13,
              "line": 102
            }
          }
        },
        {
          "id": "108",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ 2, 3, 4 ] to deeply equal [ 2, 2, 4 ]",
          "status": "Killed",
          "testsCompleted": 13,
          "static": true,
          "killedBy": [
            "11"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 102
            },
            "start": {
              "column": 13,
              "line": 102
            }
          }
        },
        {
          "id": "109",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [ 2, 2, 2 ] to deeply equal [ 2, 2, 4 ]",
          "status": "Killed",
          "testsCompleted": 13,
          "static": true,
          "killedBy": [
            "11"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 18,
              "line": 102
            },
            "start": {
              "column": 13,
              "line": 102
            }
          }
        },
        {
          "id": "110",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(108,31): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 124
            },
            "start": {
              "column": 43,
              "line": 109
            }
          }
        },
        {
          "id": "111",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(109,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 123
            },
            "start": {
              "column": 25,
              "line": 110
            }
          }
        },
        {
          "id": "112",
          "mutatorName": "BooleanLiteral",
          "replacement": "false",
          "statusReason": "expected [ 1, undefined, 3, 1, 3 ] to deeply equal [ undefined, 1, undefined, 3, 1, 3 ]",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "9"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 111
            },
            "start": {
              "column": 17,
              "line": 111
            }
          }
        },
        {
          "id": "113",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(109,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 122
            },
            "start": {
              "column": 12,
              "line": 113
            }
          }
        },
        {
          "id": "114",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(109,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 121
            },
            "start": {
              "column": 31,
              "line": 115
            }
          }
        },
        {
          "id": "115",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ 1, 1, 2, 3, 2 ] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 116
            },
            "start": {
              "column": 22,
              "line": 116
            }
          }
        },
        {
          "id": "116",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 116
            },
            "start": {
              "column": 22,
              "line": 116
            }
          }
        },
        {
          "id": "117",
          "mutatorName": "LogicalOperator",
          "replacement": "first && last !== b",
          "statusReason": "expected [ 1 ] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 116
            },
            "start": {
              "column": 22,
              "line": 116
            }
          }
        },
        {
          "id": "118",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [ 1 ] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 116
            },
            "start": {
              "column": 31,
              "line": 116
            }
          }
        },
        {
          "id": "119",
          "mutatorName": "EqualityOperator",
          "replacement": "last === b",
          "statusReason": "expected [ 1, 1 ] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 116
            },
            "start": {
              "column": 31,
              "line": 116
            }
          }
        },
        {
          "id": "120",
          "mutatorName": "BooleanLiteral",
          "replacement": "true",
          "statusReason": "expected [ 1, 1, 2, 3, 2 ] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 22,
              "line": 117
            },
            "start": {
              "column": 17,
              "line": 117
            }
          }
        },
        {
          "id": "121",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ 1, 1, 2, 3, 2 ] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 119
            },
            "start": {
              "column": 13,
              "line": 119
            }
          }
        },
        {
          "id": "122",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ 1, 2, 3, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "8"
          ],
          "coveredBy": [
            "8",
            "9"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 119
            },
            "start": {
              "column": 13,
              "line": 119
            }
          }
        },
        {
          "id": "123",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(125,47): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "15",
            "16",
            "18",
            "20",
            "40",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 135
            },
            "start": {
              "column": 59,
              "line": 126
            }
          }
        },
        {
          "id": "124",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(126,3): error TS2322: Type '(ctx: Ctx<A, N>) => void' is not assignable to type 'Op<A, N, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "15",
            "16",
            "18",
            "20",
            "40",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 134
            },
            "start": {
              "column": 25,
              "line": 127
            }
          }
        },
        {
          "id": "125",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(126,3): error TS2322: Type '(ctx: Ctx<A, N>) => {}' is not assignable to type 'Op<A, N, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "15",
            "16",
            "18",
            "20",
            "40",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 133
            },
            "start": {
              "column": 12,
              "line": 128
            }
          }
        },
        {
          "id": "126",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(126,3): error TS2322: Type '(ctx: Ctx<A, N>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, N, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "15",
            "16",
            "18",
            "20",
            "40",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 132
            },
            "start": {
              "column": 29,
              "line": 130
            }
          }
        },
        {
          "id": "127",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(136,63): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "14"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 148
            },
            "start": {
              "column": 75,
              "line": 137
            }
          }
        },
        {
          "id": "128",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(137,3): error TS2322: Type '(ctx: Ctx<A, N>) => void' is not assignable to type 'Op<A, N, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "14"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 147
            },
            "start": {
              "column": 25,
              "line": 138
            }
          }
        },
        {
          "id": "129",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(137,3): error TS2322: Type '(ctx: Ctx<A, N>) => {}' is not assignable to type 'Op<A, N, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "14"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 146
            },
            "start": {
              "column": 12,
              "line": 140
            }
          }
        },
        {
          "id": "130",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(137,3): error TS2322: Type '(ctx: Ctx<A, N>) => { fold: (a_: A, b_: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, N, B>'.\n  Call signature return types '{ fold: (a_: A, b_: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "14"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 145
            },
            "start": {
              "column": 31,
              "line": 142
            }
          }
        },
        {
          "id": "131",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(149,44): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 166
            },
            "start": {
              "column": 58,
              "line": 150
            }
          }
        },
        {
          "id": "132",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(150,3): error TS2322: Type '(ctx: Ctx<A, B[]>) => void' is not assignable to type 'Op<A, B[], B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 165
            },
            "start": {
              "column": 25,
              "line": 151
            }
          }
        },
        {
          "id": "133",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(150,3): error TS2322: Type '(ctx: Ctx<A, B[]>) => {}' is not assignable to type 'Op<A, B[], B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 164
            },
            "start": {
              "column": 12,
              "line": 153
            }
          }
        },
        {
          "id": "134",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(150,3): error TS2322: Type '(ctx: Ctx<A, B[]>) => { fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B[], B>'.\n  Call signature return types '{ fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 163
            },
            "start": {
              "column": 31,
              "line": 155
            }
          }
        },
        {
          "id": "135",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] to deeply equal [ [ 1, 2 ], [ 3, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 32,
              "line": 157
            },
            "start": {
              "column": 13,
              "line": 157
            }
          }
        },
        {
          "id": "136",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ [ 1, 2 ], [ 3, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 32,
              "line": 157
            },
            "start": {
              "column": 13,
              "line": 157
            }
          }
        },
        {
          "id": "137",
          "mutatorName": "EqualityOperator",
          "replacement": "acc_.length !== len",
          "statusReason": "expected [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] to deeply equal [ [ 1, 2 ], [ 3, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 32,
              "line": 157
            },
            "start": {
              "column": 13,
              "line": 157
            }
          }
        },
        {
          "id": "138",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [] to deeply equal [ [ 1, 2 ], [ 3, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 10,
              "line": 161
            },
            "start": {
              "column": 34,
              "line": 157
            }
          }
        },
        {
          "id": "139",
          "mutatorName": "ArrayDeclaration",
          "replacement": "[\"Stryker was here\"]",
          "statusReason": "src/lib/transducers/reducers.ts(158,19): error TS2322: Type 'string' is not assignable to type 'B'.\n  'B' could be instantiated with an arbitrary type which could be unrelated to 'string'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13"
          ],
          "location": {
            "end": {
              "column": 20,
              "line": 159
            },
            "start": {
              "column": 18,
              "line": 159
            }
          }
        },
        {
          "id": "140",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(167,47): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 184
            },
            "start": {
              "column": 61,
              "line": 168
            }
          }
        },
        {
          "id": "141",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(168,3): error TS2322: Type '(ctx: Ctx<A, B[]>) => void' is not assignable to type 'Op<A, B[], B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 183
            },
            "start": {
              "column": 25,
              "line": 169
            }
          }
        },
        {
          "id": "142",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(168,3): error TS2322: Type '(ctx: Ctx<A, B[]>) => {}' is not assignable to type 'Op<A, B[], B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 182
            },
            "start": {
              "column": 12,
              "line": 171
            }
          }
        },
        {
          "id": "143",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(168,3): error TS2322: Type '(ctx: Ctx<A, B[]>) => { fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B[], B>'.\n  Call signature return types '{ fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 8,
              "line": 181
            },
            "start": {
              "column": 31,
              "line": 173
            }
          }
        },
        {
          "id": "144",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [ [ 1 ], [ 2 ], [ 3 ] ] to deeply equal [ [ 1, 2 ], [ 2, 3 ] ]",
          "status": "Killed",
          "testsCompleted": 14,
          "static": true,
          "killedBy": [
            "12"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 32,
              "line": 175
            },
            "start": {
              "column": 13,
              "line": 175
            }
          }
        },
        {
          "id": "145",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ [ 1, 2 ], [ 2, 3 ] ]",
          "status": "Killed",
          "testsCompleted": 14,
          "static": true,
          "killedBy": [
            "12"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 32,
              "line": 175
            },
            "start": {
              "column": 13,
              "line": 175
            }
          }
        },
        {
          "id": "146",
          "mutatorName": "EqualityOperator",
          "replacement": "acc_.length !== len",
          "statusReason": "expected [ [ 1 ], [ 2 ], [ 3 ] ] to deeply equal [ [ 1, 2 ], [ 2, 3 ] ]",
          "status": "Killed",
          "testsCompleted": 14,
          "static": true,
          "killedBy": [
            "12"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 32,
              "line": 175
            },
            "start": {
              "column": 13,
              "line": 175
            }
          }
        },
        {
          "id": "147",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [] to deeply equal [ [ 1, 2 ], [ 2, 3 ] ]",
          "status": "Killed",
          "testsCompleted": 14,
          "static": true,
          "killedBy": [
            "12"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 10,
              "line": 179
            },
            "start": {
              "column": 34,
              "line": 175
            }
          }
        },
        {
          "id": "148",
          "mutatorName": "MethodExpression",
          "replacement": "acc_",
          "statusReason": "expected [ [ 1, 2, 3 ] ] to deeply equal [ [ 1, 2 ], [ 2, 3 ] ]",
          "status": "Killed",
          "testsCompleted": 14,
          "static": true,
          "killedBy": [
            "12"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 31,
              "line": 177
            },
            "start": {
              "column": 18,
              "line": 177
            }
          }
        },
        {
          "id": "149",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(189,4): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "19"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 199
            },
            "start": {
              "column": 16,
              "line": 190
            }
          }
        },
        {
          "id": "150",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(190,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "19"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 198
            },
            "start": {
              "column": 25,
              "line": 191
            }
          }
        },
        {
          "id": "151",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(190,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "19"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 197
            },
            "start": {
              "column": 12,
              "line": 192
            }
          }
        },
        {
          "id": "152",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(190,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "19"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 196
            },
            "start": {
              "column": 31,
              "line": 194
            }
          }
        },
        {
          "id": "153",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(203,4): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "16",
            "17",
            "18",
            "20"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 213
            },
            "start": {
              "column": 16,
              "line": 204
            }
          }
        },
        {
          "id": "154",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(204,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, Q>'.\n  Type 'void' is not assignable to type 'Ctx<A, Q>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "16",
            "17",
            "18",
            "20"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 212
            },
            "start": {
              "column": 25,
              "line": 205
            }
          }
        },
        {
          "id": "155",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(204,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, Q>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, Q>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "16",
            "17",
            "18",
            "20"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 211
            },
            "start": {
              "column": 12,
              "line": 206
            }
          }
        },
        {
          "id": "156",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(204,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (acc: A, b: Q) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, Q>'.\n  Call signature return types '{ fold: (acc: A, b: Q) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, Q>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "16",
            "17",
            "18",
            "20"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 210
            },
            "start": {
              "column": 31,
              "line": 208
            }
          }
        },
        {
          "id": "157",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(218,4): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 234
            },
            "start": {
              "column": 21,
              "line": 219
            }
          }
        },
        {
          "id": "158",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(219,3): error TS2322: Type '(ctx: Ctx<A, [B, C]>) => void' is not assignable to type 'Op<A, [B, C], B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 233
            },
            "start": {
              "column": 25,
              "line": 220
            }
          }
        },
        {
          "id": "159",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(219,3): error TS2322: Type '(ctx: Ctx<A, [B, C]>) => {}' is not assignable to type 'Op<A, [B, C], B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 232
            },
            "start": {
              "column": 12,
              "line": 222
            }
          }
        },
        {
          "id": "160",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(219,3): error TS2322: Type '(ctx: Ctx<A, [B, C]>) => { fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, [B, C], B>'.\n  Call signature return types '{ fold: (acc: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 231
            },
            "start": {
              "column": 31,
              "line": 224
            }
          }
        },
        {
          "id": "161",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 226
            },
            "start": {
              "column": 13,
              "line": 226
            }
          }
        },
        {
          "id": "162",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [ [ 1, 4 ], [ 2, undefined ], …(1) ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "21",
            "22",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 226
            },
            "start": {
              "column": 13,
              "line": 226
            }
          }
        },
        {
          "id": "163",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [ [ 1, 4 ], [ 2, undefined ], …(1) ] to deeply equal [ [ 1, 4 ] ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "23",
            "24",
            "25"
          ],
          "location": {
            "end": {
              "column": 10,
              "line": 228
            },
            "start": {
              "column": 21,
              "line": 226
            }
          }
        },
        {
          "id": "59",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(17,40): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": true,
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 30
            },
            "start": {
              "column": 52,
              "line": 17
            }
          }
        },
        {
          "id": "60",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(18,3): error TS2322: Type '(ctx: Ctx<A, B>) => void' is not assignable to type 'Op<A, B, B>'.\n  Type 'void' is not assignable to type 'Ctx<A, B>'.\n",
          "status": "CompileError",
          "static": true,
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 29
            },
            "start": {
              "column": 25,
              "line": 18
            }
          }
        },
        {
          "id": "61",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(18,3): error TS2322: Type '(ctx: Ctx<A, B>) => {}' is not assignable to type 'Op<A, B, B>'.\n  Type '{}' is missing the following properties from type 'Ctx<A, B>': fold, cut, close, step, transform\n",
          "status": "CompileError",
          "static": true,
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 28
            },
            "start": {
              "column": 12,
              "line": 20
            }
          }
        },
        {
          "id": "62",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.ts(18,3): error TS2322: Type '(ctx: Ctx<A, B>) => { fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<...>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' is not assignable to type 'Op<A, B, B>'.\n  Call signature return types '{ fold: (a: A, b: B) => void; cut: () => never; close: () => void; step: <C, P, Q, N>(op: Op<C[], C, N>, init: Q, coll: ICollection<P, Q, N>) => () => IteratorResult<C, any>; transform: <P, Q, N>(op: Op<...>, acc: A, fold: (a: A, b: N) => A, init: Q, coll: ICollection<...>) => A; }' and 'Ctx<A, B>' are incompatible.\n    The types returned by 'fold(...)' are incompatible between these types.\n      Type 'void' is not assignable to type 'A'.\n        'A' could be instantiated with an arbitrary type which could be unrelated to 'void'.\n",
          "status": "CompileError",
          "static": true,
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 27
            },
            "start": {
              "column": 29,
              "line": 22
            }
          }
        },
        {
          "id": "66",
          "mutatorName": "EqualityOperator",
          "replacement": "i !== n",
          "statusReason": "expected [ 'kayak' ] to deeply equal [ 'kayak', 'chair' ]",
          "status": "Killed",
          "static": true,
          "testsCompleted": 5,
          "killedBy": [
            "3"
          ],
          "coveredBy": [
            "24"
          ],
          "location": {
            "end": {
              "column": 20,
              "line": 25
            },
            "start": {
              "column": 13,
              "line": 25
            }
          }
        }
      ],
      "source": "import { Ctx } from \"./core\";\nimport { ICollection } from \"./transformers\";\n\nexport type Op<A, B, N> = (c: Ctx<A, B>) => Ctx<A, N>;\n\nexport function id<A, B>(): Op<A, B, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        return ctx.fold(a, b);\n      },\n    };\n  };\n}\n\nexport function take<A, B>(n: number): Op<A, B, B> {\n  return function (ctx) {\n    let i = 0;\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        i++;\n        // Stryker disable next-line ConditionalExpression\n        if (i === n) ctx.close();\n        return ctx.fold(a, b);\n      },\n    };\n  };\n}\n\nexport function drop<A, B>(n: number): Op<A, B, B> {\n  return function (ctx) {\n    let i = 0;\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        i++;\n        if (i > n) return ctx.fold(a, b);\n        return a;\n      },\n    };\n  };\n}\n\nexport function takeWhile<A, B>(c: (b: B) => boolean): Op<A, B, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        if (c(b)) return ctx.fold(a, b);\n        return ctx.cut(); // return is needed to have correct typing\n      },\n    };\n  };\n}\n\nexport function dropWhile<A, B>(c: (b: B) => boolean): Op<A, B, B> {\n  return function (ctx) {\n    let dropping = true;\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        dropping &&= c(b);\n        if (dropping) return a;\n        return ctx.fold(a, b);\n      },\n    };\n  };\n}\n\nexport function find<A, B>(c: (b: B) => boolean): Op<A, B, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        if (!c(b)) return ctx.fold(a, b);\n        ctx.close();\n        return ctx.fold(a, b);\n      },\n    };\n  };\n}\n\nexport function filter<A, B>(c: (b: B) => boolean): Op<A, B, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        if (c(b)) return ctx.fold(a, b);\n        return a;\n      },\n    };\n  };\n}\n\nexport function replace<A, B>(c: (b: B) => boolean, v: B): Op<A, B, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        if (!c(b)) return ctx.fold(a, b);\n        return ctx.fold(a, v);\n      },\n    };\n  };\n}\n\nexport function uniq<A, B>(): Op<A, B, B> {\n  return function (ctx) {\n    let first = true;\n    let last: B | undefined = undefined;\n    return {\n      ...ctx,\n      fold: function (acc, b) {\n        const pass = first || last !== b;\n        first = false;\n        last = b;\n        if (pass) return ctx.fold(acc, b);\n        return acc;\n      },\n    };\n  };\n}\n\nexport function map<A, B, N>(f: (v: B) => N): Op<A, N, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (a, b) {\n        return ctx.fold(a, f(b));\n      },\n    };\n  };\n}\n\nexport function fold<A, B, N>(f: (a: N, b: B) => N, init: N): Op<A, N, B> {\n  return function (ctx) {\n    let acc_ = init;\n    return {\n      ...ctx,\n      fold: function (a_, b_) {\n        acc_ = f(acc_, b_);\n        return ctx.fold(a_, acc_);\n      },\n    };\n  };\n}\n\nexport function slices<A, B>(len: number): Op<A, B[], B> {\n  return function (ctx) {\n    let acc_ = [] as B[];\n    return {\n      ...ctx,\n      fold: function (acc, b) {\n        acc_.push(b);\n        if (acc_.length === len) {\n          const res = acc_;\n          acc_ = [];\n          return ctx.fold(acc, res);\n        }\n        return acc;\n      },\n    };\n  };\n}\n\nexport function apertures<A, B>(len: number): Op<A, B[], B> {\n  return function (ctx) {\n    let acc_ = [] as B[];\n    return {\n      ...ctx,\n      fold: function (acc, b) {\n        acc_.push(b);\n        if (acc_.length === len) {\n          const res = acc_;\n          acc_ = acc_.slice(1);\n          return ctx.fold(acc, res);\n        }\n        return acc;\n      },\n    };\n  };\n}\n\nexport function chain<A, B, Q>(\n  coll: ICollection<any, Q, B>,\n  f: (b: B) => Q,\n  op: Op<A, B, B> = id<A, B>(),\n): Op<A, B, B> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (acc, b) {\n        return ctx.transform(op, acc, ctx.fold, f(b), coll);\n      },\n    };\n  };\n}\n\nexport function flatten<A, B, Q>(\n  coll: ICollection<any, Q, B>,\n  op: Op<A, B, B> = id<A, B>(),\n): Op<A, B, Q> {\n  return function (ctx) {\n    return {\n      ...ctx,\n      fold: function (acc, b) {\n        return ctx.transform(op, acc, ctx.fold, b, coll);\n      },\n    };\n  };\n}\n\nexport function zip<A, B, C, Q>(\n  coll: ICollection<any, Q, C>,\n  right: Q,\n  op: Op<C[], C, C> = id<C[], C>(),\n): Op<A, [B, C], B> {\n  return function (ctx) {\n    const iter = ctx.step(op, right, coll);\n    return {\n      ...ctx,\n      fold: function (acc, b) {\n        const r = iter();\n        if (r.done) {\n          return ctx.cut();\n        }\n        const c = r.value;\n        return ctx.fold(acc, [b, c] as const);\n      },\n    };\n  };\n}\n"
    },
    "src/lib/transducers/transformers.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "164",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(74,22): error TS2635: Type '() => undefined' has no signatures for which the type argument list is applicable.\nsrc/lib/transducers/transformers.ts(85,22): error TS2635: Type '() => undefined' has no signatures for which the type argument list is applicable.\nsrc/lib/transducers/transformers.ts(91,21): error TS2635: Type '() => undefined' has no signatures for which the type argument list is applicable.\nsrc/lib/transducers/transformers.ts(100,3): error TS2322: Type '{ setup: {}; unfold: (xs: T[]) => readonly [T[], T] | undefined; }' is not assignable to type 'ICollection<T[], T[], T>'.\n  Types of property 'setup' are incompatible.\n    Type '{}' is not assignable to type '(a: T[]) => T[]'.\n      Type '{}' provides no match for the signature '(a: T[]): T[]'.\nsrc/lib/transducers/transformers.ts(121,21): error TS2635: Type '() => undefined' has no signatures for which the type argument list is applicable.\nsrc/lib/transducers/transformers.ts(131,31): error TS2345: Argument of type '{ setup: {}; unfold: (acc: T) => readonly [T, T] | undefined; }' is not assignable to parameter of type 'ICollection<T, T, T>'.\n  Types of property 'setup' are incompatible.\n    Type '{}' is not assignable to type '(a: T) => T'.\n      Type '{}' provides no match for the signature '(a: T): T'.\nsrc/lib/transducers/transformers.ts(144,21): error TS2635: Type '() => undefined' has no signatures for which the type argument list is applicable.\nsrc/lib/transducers/transformers.ts(155,31): error TS2345: Argument of type '{ setup: {}; unfold: (acc: T) => readonly [T, T] | undefined; }' is not assignable to parameter of type 'ICollection<T, T, T>'.\n  Types of property 'setup' are incompatible.\n    Type '{}' is not assignable to type '(a: T) => T'.\n      Type '{}' provides no match for the signature '(a: T): T'.\nsrc/lib/transducers/reducers.test.ts(33,29): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(55,11): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: {}; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], unknown>'.\nsrc/lib/transducers/reducers.test.ts(71,38): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => string[]; result: {}; }' is not assignable to parameter of type 'IXForm<string[], string, unknown>'.\nsrc/lib/transducers/reducers.test.ts(76,53): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => string[]; result: {}; }' is not assignable to parameter of type 'IXForm<string[], string, unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: string[]) => unknown'.\n      Type '{}' provides no match for the signature '(a: string[]): unknown'.\nsrc/lib/transducers/reducers.test.ts(83,7): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => string[]; result: {}; }' is not assignable to parameter of type 'IXForm<string[], string, unknown>'.\nsrc/lib/transducers/reducers.test.ts(91,53): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => string[]; result: {}; }' is not assignable to parameter of type 'IXForm<string[], string, unknown>'.\nsrc/lib/transducers/reducers.test.ts(98,41): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(104,41): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(110,44): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(115,9): error TS2345: Argument of type '{ init: () => (number | undefined)[]; fold: (acc: (number | undefined)[], b: number | undefined) => (number | undefined)[]; result: {}; }' is not assignable to parameter of type 'IXForm<(number | undefined)[], number | undefined, unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: (number | undefined)[]) => unknown'.\n      Type '{}' provides no match for the signature '(a: (number | undefined)[]): unknown'.\nsrc/lib/transducers/reducers.test.ts(122,36): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: number[]) => unknown'.\n      Type '{}' provides no match for the signature '(a: number[]): unknown'.\nsrc/lib/transducers/reducers.test.ts(129,7): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(137,36): error TS2345: Argument of type '{ init: () => number[][]; fold: (acc: number[][], b: number[]) => number[][]; result: {}; }' is not assignable to parameter of type 'IXForm<number[][], number[], unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: number[][]) => unknown'.\n      Type '{}' provides no match for the signature '(a: number[][]): unknown'.\nsrc/lib/transducers/reducers.test.ts(147,44): error TS2345: Argument of type '{ init: () => number[][]; fold: (acc: number[][], b: number[]) => number[][]; result: {}; }' is not assignable to parameter of type 'IXForm<number[][], number[], unknown>'.\nsrc/lib/transducers/reducers.test.ts(157,9): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(166,38): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(175,10): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(180,9): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(187,9): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(204,11): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(211,11): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/reducers.test.ts(222,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: {}; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: [number, number][]) => unknown'.\n      Type '{}' provides no match for the signature '(a: [number, number][]): unknown'.\nsrc/lib/transducers/reducers.test.ts(233,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: {}; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], unknown>'.\nsrc/lib/transducers/reducers.test.ts(243,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: {}; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], unknown>'.\nsrc/lib/transducers/reducers.test.ts(253,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: {}; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], unknown>'.\nsrc/lib/transducers/reducers.test.ts(260,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: {}; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], unknown>'.\nsrc/lib/transducers/transformers.test.ts(25,38): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(35,7): error TS2345: Argument of type '{ init: () => Map<number, number>; fold: (acc: Map<number, number>, [k, v]: [number, number]) => Map<number, number>; result: {}; }' is not assignable to parameter of type 'IXForm<Map<number, number>, [number, number], unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: Map<number, number>) => unknown'.\n      Type '{}' provides no match for the signature '(a: Map<number, number>): unknown'.\nsrc/lib/transducers/transformers.test.ts(37,25): error TS18046: 'xs' is of type 'unknown'.\nsrc/lib/transducers/transformers.test.ts(79,32): error TS2345: Argument of type '{ init: () => unknown[]; fold: (acc: unknown[], b: unknown) => unknown[]; result: {}; }' is not assignable to parameter of type 'IXForm<unknown[], unknown, unknown>'.\n  Types of property 'result' are incompatible.\n    Type '{}' is not assignable to type '(a: unknown[]) => unknown'.\n      Type '{}' provides no match for the signature '(a: unknown[]): unknown'.\nsrc/lib/transducers/transformers.test.ts(85,51): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(93,30): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(97,38): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(101,40): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(109,39): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => number[]; result: {}; }' is not assignable to parameter of type 'IXForm<number[], number, unknown>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 39,
              "line": 4
            },
            "start": {
              "column": 25,
              "line": 4
            }
          }
        },
        {
          "id": "165",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(24,20): error TS2554: Expected 0 arguments, but got 1.\nsrc/lib/transducers/transformers.ts(32,20): error TS2554: Expected 0 arguments, but got 1.\nsrc/lib/transducers/transformers.ts(109,22): error TS2554: Expected 0 arguments, but got 1.\nsrc/lib/transducers/transformers.test.ts(45,37): error TS2345: Argument of type '{ init: undefined; fold: (_acc: number | undefined, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number, number, unknown>'.\n  Types of property 'init' are incompatible.\n    Type 'undefined' is not assignable to type '() => number'.\nsrc/lib/transducers/transformers.test.ts(51,34): error TS2345: Argument of type '{ init: undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number, number, unknown>'.\n  Types of property 'init' are incompatible.\n    Type 'undefined' is not assignable to type '() => number'.\nsrc/lib/transducers/transformers.test.ts(55,28): error TS2345: Argument of type '{ init: undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number, number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(61,37): error TS2345: Argument of type '{ init: undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number, number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(65,28): error TS2345: Argument of type '{ init: undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number, number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(71,43): error TS2345: Argument of type '{ init: undefined; fold: (a: string, b: string) => string; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<string, string, unknown>'.\n  Types of property 'init' are incompatible.\n    Type 'undefined' is not assignable to type '() => string'.\nsrc/lib/transducers/transformers.test.ts(75,35): error TS2345: Argument of type '{ init: undefined; fold: (a: string, b: string) => string; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<string, string, unknown>'.\nsrc/lib/transducers/transformers.test.ts(118,9): error TS2345: Argument of type '{ init: undefined; fold: (acc: (a: number) => void, b: number) => (a: number) => void; result: () => void; }' is not assignable to parameter of type 'IXForm<(a: number) => void, number, void>'.\n  Types of property 'init' are incompatible.\n    Type 'undefined' is not assignable to type '() => (a: number) => void'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 8
            },
            "start": {
              "column": 3,
              "line": 6
            }
          }
        },
        {
          "id": "166",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.test.ts(51,34): error TS2345: Argument of type '{ init: () => undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number | undefined, number, unknown>'.\n  Types of property 'fold' are incompatible.\n    Type '(a: number, b: number) => number' is not assignable to type '(a: number | undefined, b: number) => number | undefined'.\n      Types of parameters 'a' and 'a' are incompatible.\n        Type 'number | undefined' is not assignable to type 'number'.\n          Type 'undefined' is not assignable to type 'number'.\nsrc/lib/transducers/transformers.test.ts(55,28): error TS2345: Argument of type '{ init: () => undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number | undefined, number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(61,37): error TS2345: Argument of type '{ init: () => undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number | undefined, number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(65,28): error TS2345: Argument of type '{ init: () => undefined; fold: (a: number, b: number) => number; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<number | undefined, number, unknown>'.\nsrc/lib/transducers/transformers.test.ts(71,43): error TS2345: Argument of type '{ init: () => undefined; fold: (a: string, b: string) => string; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<string | undefined, string, unknown>'.\n  Types of property 'fold' are incompatible.\n    Type '(a: string, b: string) => string' is not assignable to type '(a: string | undefined, b: string) => string | undefined'.\n      Types of parameters 'a' and 'a' are incompatible.\n        Type 'string | undefined' is not assignable to type 'string'.\n          Type 'undefined' is not assignable to type 'string'.\nsrc/lib/transducers/transformers.test.ts(75,35): error TS2345: Argument of type '{ init: () => undefined; fold: (a: string, b: string) => string; result: <T>(x: T) => T; }' is not assignable to parameter of type 'IXForm<string | undefined, string, unknown>'.\nsrc/lib/transducers/transformers.test.ts(118,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: (a: number) => void, b: number) => (a: number) => void; result: () => void; }' is not assignable to parameter of type 'IXForm<(a: number) => void, number, void>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type '(a: number) => void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "28",
            "29",
            "30",
            "31",
            "32",
            "33",
            "34",
            "41"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 8
            },
            "start": {
              "column": 3,
              "line": 7
            }
          }
        },
        {
          "id": "167",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(45,37): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "28"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 30
            },
            "start": {
              "column": 29,
              "line": 24
            }
          }
        },
        {
          "id": "168",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(45,37): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "28"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 29
            },
            "start": {
              "column": 10,
              "line": 25
            }
          }
        },
        {
          "id": "169",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "expected undefined to deeply equal 3",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "28"
          ],
          "coveredBy": [
            "28"
          ],
          "location": {
            "end": {
              "column": 43,
              "line": 27
            },
            "start": {
              "column": 11,
              "line": 27
            }
          }
        },
        {
          "id": "170",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(118,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "41"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 41
            },
            "start": {
              "column": 48,
              "line": 32
            }
          }
        },
        {
          "id": "171",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(118,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "41"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 40
            },
            "start": {
              "column": 10,
              "line": 33
            }
          }
        },
        {
          "id": "172",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(118,9): error TS2345: Argument of type '{ init: () => (a: number) => void; fold: (acc: (a: number) => void, b: number) => void; result: () => void; }' is not assignable to parameter of type 'IXForm<(a: number) => void, number, void>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type '(a: number) => void'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "41"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 38
            },
            "start": {
              "column": 42,
              "line": 35
            }
          }
        },
        {
          "id": "173",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(59,5): error TS2345: Argument of type '{ setup: (iterable: Iterable<T>) => void; unfold: (next: () => IteratorResult<T, any>) => readonly [() => IteratorResult<T, any>, T] | undefined; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<T, any>, Iterable<T>, T>'.\n  The types returned by 'setup(...)' are incompatible between these types.\n    Type 'void' is not assignable to type '() => IteratorResult<T, any>'.\nsrc/lib/transducers/reducers.test.ts(39,9): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => void; unfold: (next: () => IteratorResult<number, any>) => readonly [() => IteratorResult<number, any>, number] | undefined; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<number, any>, number[], number>'.\n  The types returned by 'setup(...)' are incompatible between these types.\n    Type 'void' is not assignable to type '() => IteratorResult<number, any>'.\nsrc/lib/transducers/utils.test.ts(12,9): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => void; unfold: (next: () => IteratorResult<number, any>) => readonly [() => IteratorResult<number, any>, number] | undefined; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<number, any>, number[], number>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 46
            },
            "start": {
              "column": 44,
              "line": 43
            }
          }
        },
        {
          "id": "174",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(62,5): error TS2345: Argument of type '{ setup: (iterable: Iterable<T>) => () => undefined; unfold: (next: () => IteratorResult<T, any>) => readonly [() => IteratorResult<T, any>, T] | undefined; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<T, any>, Iterable<T>, T>'.\n  The types returned by 'setup(...)()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'IteratorResult<T, any>'.\nsrc/lib/transducers/reducers.test.ts(39,9): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => () => undefined; unfold: (next: () => IteratorResult<number, any>) => readonly [() => IteratorResult<number, any>, number] | undefined; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<number, any>, number[], number>'.\n  The types returned by 'setup(...)()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'IteratorResult<number, any>'.\nsrc/lib/transducers/utils.test.ts(12,9): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => () => undefined; unfold: (next: () => IteratorResult<number, any>) => readonly [() => IteratorResult<number, any>, number] | undefined; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<number, any>, number[], number>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 45
            },
            "start": {
              "column": 10,
              "line": 45
            }
          }
        },
        {
          "id": "175",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(52,5): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<() => IteratorResult<T, any>, Iterable<T>, T>'.\nsrc/lib/transducers/reducers.test.ts(39,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<unknown, number[], unknown>'.\nsrc/lib/transducers/reducers.test.ts(42,9): error TS2345: Argument of type 'Op<[number, number][], [number, number], number>' is not assignable to parameter of type 'Op<[number, number][], [number, number], unknown>'.\n  Call signature return types 'Ctx<[number, number][], number>' and 'Ctx<[number, number][], unknown>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: [number, number][], b: number) => [number, number][]' is not assignable to type '(a: [number, number][], b: unknown) => [number, number][]'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/reducers.test.ts(43,11): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(175,37): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(181,22): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, unknown, number>'.\nsrc/lib/transducers/reducers.test.ts(181,43): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[][], unknown>'.\nsrc/lib/transducers/reducers.test.ts(188,35): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(205,17): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(212,24): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, unknown, number>'.\nsrc/lib/transducers/reducers.test.ts(223,13): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(234,13): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(244,13): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(254,13): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/utils.test.ts(12,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<unknown, number[], unknown>'.\nsrc/lib/transducers/utils.test.ts(14,17): error TS2345: Argument of type 'Op<number[], number, number>' is not assignable to parameter of type 'Op<number[], number, unknown>'.\n  Call signature return types 'Ctx<number[], number>' and 'Ctx<number[], unknown>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: number[], b: number) => number[]' is not assignable to type '(a: number[], b: unknown) => number[]'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'unknown' is not assignable to type 'number'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 58
            },
            "start": {
              "column": 31,
              "line": 48
            }
          }
        },
        {
          "id": "176",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(55,5): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<() => IteratorResult<T, any>, Iterable<T>, T>'.\n  Type '{}' is missing the following properties from type 'ICollection<() => IteratorResult<T, any>, Iterable<T>, T>': setup, unfold\nsrc/lib/transducers/reducers.test.ts(39,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<unknown, number[], unknown>'.\n  Type '{}' is missing the following properties from type 'ICollection<unknown, number[], unknown>': setup, unfold\nsrc/lib/transducers/reducers.test.ts(42,9): error TS2345: Argument of type 'Op<[number, number][], [number, number], number>' is not assignable to parameter of type 'Op<[number, number][], [number, number], unknown>'.\n  Call signature return types 'Ctx<[number, number][], number>' and 'Ctx<[number, number][], unknown>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: [number, number][], b: number) => [number, number][]' is not assignable to type '(a: [number, number][], b: unknown) => [number, number][]'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/reducers.test.ts(43,11): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\n  Type '{}' is missing the following properties from type 'ICollection<any, number[], number>': setup, unfold\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(175,37): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(181,22): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, unknown, number>'.\n  Type '{}' is missing the following properties from type 'ICollection<any, unknown, number>': setup, unfold\nsrc/lib/transducers/reducers.test.ts(181,43): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[][], unknown>'.\n  Type '{}' is missing the following properties from type 'ICollection<any, number[][], unknown>': setup, unfold\nsrc/lib/transducers/reducers.test.ts(188,35): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(205,17): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(212,24): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, unknown, number>'.\nsrc/lib/transducers/reducers.test.ts(223,13): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(234,13): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(244,13): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(254,13): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/utils.test.ts(12,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<unknown, number[], unknown>'.\nsrc/lib/transducers/utils.test.ts(14,17): error TS2345: Argument of type 'Op<number[], number, number>' is not assignable to parameter of type 'Op<number[], number, unknown>'.\n  Call signature return types 'Ctx<number[], number>' and 'Ctx<number[], unknown>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: number[], b: number) => number[]' is not assignable to type '(a: number[], b: unknown) => number[]'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'unknown' is not assignable to type 'number'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 56
            },
            "start": {
              "column": 16,
              "line": 49
            }
          }
        },
        {
          "id": "177",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(58,5): error TS2345: Argument of type '{ setup: (iterable: Iterable<T>) => () => IteratorResult<T, any>; unfold: (next: () => IteratorResult<T, any>) => void; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<T, any>, Iterable<T>, T>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [() => IteratorResult<T, any>, T] | undefined'.\nsrc/lib/transducers/reducers.test.ts(39,9): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => () => IteratorResult<number, any>; unfold: (next: () => IteratorResult<number, any>) => void; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<number, any>, number[], unknown>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [() => IteratorResult<number, any>, unknown] | undefined'.\nsrc/lib/transducers/reducers.test.ts(42,9): error TS2345: Argument of type 'Op<[number, number][], [number, number], number>' is not assignable to parameter of type 'Op<[number, number][], [number, number], unknown>'.\n  Call signature return types 'Ctx<[number, number][], number>' and 'Ctx<[number, number][], unknown>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: [number, number][], b: number) => [number, number][]' is not assignable to type '(a: [number, number][], b: unknown) => [number, number][]'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/reducers.test.ts(43,11): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [any, number] | undefined'.\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(175,37): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => () => IteratorResult<number, any>; unfold: (next: () => IteratorResult<number, any>) => void; }' is not assignable to parameter of type 'ICollection<any, Iterable<number>, number>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [any, number] | undefined'.\nsrc/lib/transducers/reducers.test.ts(181,22): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, Iterable<unknown>, number>'.\n  Types of property 'unfold' are incompatible.\n    Type '(next: () => IteratorResult<unknown, any>) => void' is not assignable to type '(unacc: any) => readonly [any, number] | undefined'.\nsrc/lib/transducers/reducers.test.ts(181,43): error TS2345: Argument of type '{ setup: (iterable: Iterable<number[]>) => () => IteratorResult<number[], any>; unfold: (next: () => IteratorResult<number[], any>) => void; }' is not assignable to parameter of type 'ICollection<any, Iterable<number[]>, Iterable<unknown>>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [any, Iterable<unknown>] | undefined'.\nsrc/lib/transducers/reducers.test.ts(188,35): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => () => IteratorResult<number, any>; unfold: (next: () => IteratorResult<number, any>) => void; }' is not assignable to parameter of type 'ICollection<any, Iterable<number>, number>'.\nsrc/lib/transducers/reducers.test.ts(205,17): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(212,24): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, Iterable<unknown>, number>'.\nsrc/lib/transducers/reducers.test.ts(223,13): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(234,13): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(244,13): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(254,13): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => void; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/utils.test.ts(12,9): error TS2345: Argument of type '{ setup: (iterable: Iterable<number>) => () => IteratorResult<number, any>; unfold: (next: () => IteratorResult<number, any>) => void; }' is not assignable to parameter of type 'ICollection<() => IteratorResult<number, any>, number[], unknown>'.\nsrc/lib/transducers/utils.test.ts(14,17): error TS2345: Argument of type 'Op<number[], number, number>' is not assignable to parameter of type 'Op<number[], number, unknown>'.\n  Call signature return types 'Ctx<number[], number>' and 'Ctx<number[], unknown>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: number[], b: number) => number[]' is not assignable to type '(a: number[], b: unknown) => number[]'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'unknown' is not assignable to type 'number'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 55
            },
            "start": {
              "column": 59,
              "line": 51
            }
          }
        },
        {
          "id": "178",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": true,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 15,
              "line": 53
            },
            "start": {
              "column": 11,
              "line": 53
            }
          }
        },
        {
          "id": "179",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "status": "Timeout",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41",
            "42"
          ],
          "location": {
            "end": {
              "column": 15,
              "line": 53
            },
            "start": {
              "column": 11,
              "line": 53
            }
          }
        },
        {
          "id": "180",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.test.ts(33,9): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(54,9): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(71,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(76,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(82,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(91,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(98,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(104,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(110,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(114,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(122,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(128,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(137,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(147,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(156,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(166,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(172,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(175,37): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, Iterable<unknown>, number>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'readonly [() => IteratorResult<unknown, any>, unknown] | undefined' is not assignable to type 'readonly [any, number] | undefined'.\n      Type 'readonly [() => IteratorResult<unknown, any>, unknown]' is not assignable to type 'readonly [any, number]'.\n        Type at position 1 in source is not compatible with type at position 1 in target.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/reducers.test.ts(179,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(186,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(203,20): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(205,17): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(210,20): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(221,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(232,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(242,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(252,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(259,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\n  Types of property 'unfold' are incompatible.\n    Type '(next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined' is not assignable to type '(unacc: any) => readonly [any, number] | undefined'.\nsrc/lib/transducers/transformers.test.ts(25,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(30,16): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(45,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(51,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(61,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(71,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(117,7): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "28",
            "29",
            "31",
            "33",
            "41"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 65
            },
            "start": {
              "column": 48,
              "line": 60
            }
          }
        },
        {
          "id": "181",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(35,7): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(37,25): error TS18046: 'xs' is of type 'unknown'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 76
            },
            "start": {
              "column": 31,
              "line": 67
            }
          }
        },
        {
          "id": "182",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(35,7): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/transformers.test.ts(37,25): error TS18046: 'xs' is of type 'unknown'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 4,
              "line": 75
            },
            "start": {
              "column": 10,
              "line": 68
            }
          }
        },
        {
          "id": "183",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.test.ts(35,7): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: Map<number, number>, [k, v]: [number, number]) => Map<number, number>; result: (x: Map<number, number>) => Map<number, number>; }' is not assignable to parameter of type 'IXForm<Map<number, number>, [number, number], Map<number, number>>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'Map<number, number>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 32,
              "line": 69
            },
            "start": {
              "column": 11,
              "line": 69
            }
          }
        },
        {
          "id": "184",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(35,7): error TS2345: Argument of type '{ init: () => Map<number, number>; fold: (acc: Map<number, number>, [k, v]: [number, number]) => void; result: (x: Map<number, number>) => Map<number, number>; }' is not assignable to parameter of type 'IXForm<Map<number, number>, [number, number], Map<number, number>>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'Map<number, number>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 6,
              "line": 73
            },
            "start": {
              "column": 53,
              "line": 70
            }
          }
        },
        {
          "id": "185",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(75,18): error TS2339: Property 'init' does not exist on type 'void'.\nsrc/lib/transducers/core.ts(76,21): error TS2339: Property 'fold' does not exist on type 'void'.\nsrc/lib/transducers/reducers.test.ts(33,29): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(55,11): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(71,38): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(76,53): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(83,7): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(91,53): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(98,41): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(104,41): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(110,44): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(115,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(122,36): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(129,7): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(137,36): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(147,44): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(157,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(166,38): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(175,10): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(180,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(187,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(204,11): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(211,11): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(222,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(233,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(243,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(253,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(260,9): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'readonly [() => IteratorResult<unknown, any>, unknown] | undefined' is not assignable to type 'readonly [any, number] | undefined'.\n      Type 'readonly [() => IteratorResult<unknown, any>, unknown]' is not assignable to type 'readonly [any, number]'.\n        Type at position 1 in source is not compatible with type at position 1 in target.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/transformers.test.ts(25,38): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(79,32): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(85,51): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(93,30): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(97,38): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(101,40): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(109,39): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "35",
            "36",
            "38",
            "39",
            "40",
            "42"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 87
            },
            "start": {
              "column": 30,
              "line": 78
            }
          }
        },
        {
          "id": "186",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(75,18): error TS2339: Property 'init' does not exist on type '{}'.\nsrc/lib/transducers/core.ts(76,21): error TS2339: Property 'fold' does not exist on type '{}'.\nsrc/lib/transducers/reducers.test.ts(33,29): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(55,11): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(56,15): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\nsrc/lib/transducers/reducers.test.ts(71,38): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(76,53): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/reducers.test.ts(83,7): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(91,53): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(98,41): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(104,41): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(110,44): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(115,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/reducers.test.ts(122,36): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/reducers.test.ts(129,7): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(137,36): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/reducers.test.ts(147,44): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(157,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(166,38): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(175,10): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(180,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(187,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(204,11): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(211,11): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(222,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/reducers.test.ts(233,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(243,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(253,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(260,9): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/reducers.test.ts(262,11): error TS2345: Argument of type '{ setup: (iterable: Iterable<unknown>) => () => IteratorResult<unknown, any>; unfold: (next: () => IteratorResult<unknown, any>) => readonly [() => IteratorResult<unknown, any>, unknown] | undefined; }' is not assignable to parameter of type 'ICollection<any, number[], number>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'readonly [() => IteratorResult<unknown, any>, unknown] | undefined' is not assignable to type 'readonly [any, number] | undefined'.\n      Type 'readonly [() => IteratorResult<unknown, any>, unknown]' is not assignable to type 'readonly [any, number]'.\n        Type at position 1 in source is not compatible with type at position 1 in target.\n          Type 'unknown' is not assignable to type 'number'.\nsrc/lib/transducers/transformers.test.ts(25,38): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(79,32): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/transformers.test.ts(85,51): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(93,30): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(97,38): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(101,40): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(109,39): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "35",
            "36",
            "38",
            "39",
            "40",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 86
            },
            "start": {
              "column": 10,
              "line": 79
            }
          }
        },
        {
          "id": "187",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/core.ts(90,11): error TS18048: 'acc' is possibly 'undefined'.\nsrc/lib/transducers/core.ts(91,21): error TS18048: 'acc' is possibly 'undefined'.\nsrc/lib/transducers/core.ts(102,9): error TS2322: Type 'B[]' is not assignable to type 'undefined'.\nsrc/lib/transducers/core.ts(102,21): error TS2345: Argument of type 'undefined' is not assignable to parameter of type 'B[]'.\nsrc/lib/transducers/core.ts(109,9): error TS18048: 'acc' is possibly 'undefined'.\nsrc/lib/transducers/core.ts(110,19): error TS18048: 'acc' is possibly 'undefined'.\nsrc/lib/transducers/reducers.test.ts(33,29): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(55,11): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(71,38): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: string[], b: string) => string[]; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\nsrc/lib/transducers/reducers.test.ts(76,53): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: string[], b: string) => string[]; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'string[]'.\nsrc/lib/transducers/reducers.test.ts(83,7): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: string[], b: string) => string[]; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\nsrc/lib/transducers/reducers.test.ts(91,53): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: string[], b: string) => string[]; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\nsrc/lib/transducers/reducers.test.ts(98,41): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(104,41): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(110,44): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(115,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: (number | undefined)[], b: number | undefined) => (number | undefined)[]; result: (x: (number | undefined)[]) => (number | undefined)[]; }' is not assignable to parameter of type 'IXForm<(number | undefined)[], number | undefined, (number | undefined)[]>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type '(number | undefined)[]'.\nsrc/lib/transducers/reducers.test.ts(122,36): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'number[]'.\nsrc/lib/transducers/reducers.test.ts(129,7): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(137,36): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[][], b: number[]) => number[][]; result: (x: number[][]) => number[][]; }' is not assignable to parameter of type 'IXForm<number[][], number[], number[][]>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'number[][]'.\nsrc/lib/transducers/reducers.test.ts(147,44): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[][], b: number[]) => number[][]; result: (x: number[][]) => number[][]; }' is not assignable to parameter of type 'IXForm<number[][], number[], number[][]>'.\nsrc/lib/transducers/reducers.test.ts(157,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(166,38): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(175,10): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(180,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(187,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(204,11): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(211,11): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(222,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type '[number, number][]'.\nsrc/lib/transducers/reducers.test.ts(233,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(243,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(253,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(260,9): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: [number, number][], b: [number, number]) => [number, number][]; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/transformers.test.ts(25,38): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(79,32): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: unknown[], b: unknown) => unknown[]; result: (x: unknown[]) => unknown[]; }' is not assignable to parameter of type 'IXForm<unknown[], unknown, unknown[]>'.\n  The types returned by 'init()' are incompatible between these types.\n    Type 'undefined' is not assignable to type 'unknown[]'.\nsrc/lib/transducers/transformers.test.ts(85,51): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(93,30): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(97,38): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(101,40): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(109,39): error TS2345: Argument of type '{ init: () => undefined; fold: (acc: number[], b: number) => number[]; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "35",
            "36",
            "38",
            "39",
            "40",
            "42"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 80
            },
            "start": {
              "column": 11,
              "line": 80
            }
          }
        },
        {
          "id": "188",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/core.ts(81,5): error TS2322: Type '(acc: B[], b: B) => void' is not assignable to type '(a: B[], b: B) => B[]'.\n  Type 'void' is not assignable to type 'B[]'.\nsrc/lib/transducers/reducers.test.ts(33,29): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(55,11): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => void; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(71,38): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => void; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\nsrc/lib/transducers/reducers.test.ts(76,53): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => void; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'string[]'.\nsrc/lib/transducers/reducers.test.ts(83,7): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => void; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\nsrc/lib/transducers/reducers.test.ts(91,53): error TS2345: Argument of type '{ init: () => string[]; fold: (acc: string[], b: string) => void; result: (x: string[]) => string[]; }' is not assignable to parameter of type 'IXForm<string[], string, string[]>'.\nsrc/lib/transducers/reducers.test.ts(98,41): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(104,41): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(110,44): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(115,9): error TS2345: Argument of type '{ init: () => (number | undefined)[]; fold: (acc: (number | undefined)[], b: number | undefined) => void; result: (x: (number | undefined)[]) => (number | undefined)[]; }' is not assignable to parameter of type 'IXForm<(number | undefined)[], number | undefined, (number | undefined)[]>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type '(number | undefined)[]'.\nsrc/lib/transducers/reducers.test.ts(122,36): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'number[]'.\nsrc/lib/transducers/reducers.test.ts(129,7): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(137,36): error TS2345: Argument of type '{ init: () => number[][]; fold: (acc: number[][], b: number[]) => void; result: (x: number[][]) => number[][]; }' is not assignable to parameter of type 'IXForm<number[][], number[], number[][]>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'number[][]'.\nsrc/lib/transducers/reducers.test.ts(147,44): error TS2345: Argument of type '{ init: () => number[][]; fold: (acc: number[][], b: number[]) => void; result: (x: number[][]) => number[][]; }' is not assignable to parameter of type 'IXForm<number[][], number[], number[][]>'.\nsrc/lib/transducers/reducers.test.ts(157,9): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(166,38): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(175,10): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(180,9): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(187,9): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(204,11): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(211,11): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/reducers.test.ts(222,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => void; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type '[number, number][]'.\nsrc/lib/transducers/reducers.test.ts(233,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => void; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(243,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => void; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(253,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => void; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/reducers.test.ts(260,9): error TS2345: Argument of type '{ init: () => [number, number][]; fold: (acc: [number, number][], b: [number, number]) => void; result: (x: [number, number][]) => [number, number][]; }' is not assignable to parameter of type 'IXForm<[number, number][], [number, number], [number, number][]>'.\nsrc/lib/transducers/transformers.test.ts(25,38): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(79,32): error TS2345: Argument of type '{ init: () => unknown[]; fold: (acc: unknown[], b: unknown) => void; result: (x: unknown[]) => unknown[]; }' is not assignable to parameter of type 'IXForm<unknown[], unknown, unknown[]>'.\n  The types returned by 'fold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'unknown[]'.\nsrc/lib/transducers/transformers.test.ts(85,51): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(93,30): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(97,38): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(101,40): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\nsrc/lib/transducers/transformers.test.ts(109,39): error TS2345: Argument of type '{ init: () => number[]; fold: (acc: number[], b: number) => void; result: (x: number[]) => number[]; }' is not assignable to parameter of type 'IXForm<number[], number, number[]>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [
            "0",
            "1",
            "2",
            "6",
            "7",
            "8",
            "9",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "36",
            "38",
            "39",
            "40",
            "42"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 84
            },
            "start": {
              "column": 37,
              "line": 81
            }
          }
        },
        {
          "id": "189",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(89,33): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 101
            },
            "start": {
              "column": 58,
              "line": 89
            }
          }
        },
        {
          "id": "190",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(91,3): error TS2739: Type '{}' is missing the following properties from type 'ICollection<T[], T[], T>': setup, unfold\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 99
            },
            "start": {
              "column": 16,
              "line": 90
            }
          }
        },
        {
          "id": "191",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(94,3): error TS2322: Type '{ setup: (x: T[]) => T[]; unfold: (xs: T[]) => void; }' is not assignable to type 'ICollection<T[], T[], T>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [T[], T] | undefined'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 98
            },
            "start": {
              "column": 32,
              "line": 92
            }
          }
        },
        {
          "id": "192",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "40"
          ],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 94
            },
            "start": {
              "column": 11,
              "line": 94
            }
          }
        },
        {
          "id": "193",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "Hit limit reached (401/400)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 94
            },
            "start": {
              "column": 11,
              "line": 94
            }
          }
        },
        {
          "id": "194",
          "mutatorName": "EqualityOperator",
          "replacement": "x !== undefined",
          "statusReason": "expected [] to deeply equal [ 2, 4, 6 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "40"
          ],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 94
            },
            "start": {
              "column": 11,
              "line": 94
            }
          }
        },
        {
          "id": "195",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "Hit limit reached (101/100)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 96
            },
            "start": {
              "column": 28,
              "line": 94
            }
          }
        },
        {
          "id": "196",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(109,18): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "40"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 105
            },
            "start": {
              "column": 41,
              "line": 103
            }
          }
        },
        {
          "id": "197",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(51,34): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(55,28): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(61,37): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(65,28): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(71,43): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(75,35): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 116
            },
            "start": {
              "column": 55,
              "line": 108
            }
          }
        },
        {
          "id": "198",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(51,34): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(55,28): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(61,37): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(65,28): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(71,43): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(75,35): error TS2345: Argument of type 'void' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "29",
            "30",
            "31",
            "32",
            "33",
            "34"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 115
            },
            "start": {
              "column": 22,
              "line": 109
            }
          }
        },
        {
          "id": "199",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(51,34): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/transformers.test.ts(55,28): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(61,37): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(65,28): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\nsrc/lib/transducers/transformers.test.ts(71,43): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n  Type '{}' is missing the following properties from type 'IXForm<unknown, unknown, unknown>': init, fold, result\nsrc/lib/transducers/transformers.test.ts(75,35): error TS2345: Argument of type '{}' is not assignable to parameter of type 'IXForm<unknown, unknown, unknown>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "29",
            "30",
            "31",
            "32",
            "33",
            "34"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 114
            },
            "start": {
              "column": 12,
              "line": 110
            }
          }
        },
        {
          "id": "200",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(123,31): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<T, T, T>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 127
            },
            "start": {
              "column": 34,
              "line": 119
            }
          }
        },
        {
          "id": "201",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(125,31): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<T, T, T>'.\n  Type '{}' is missing the following properties from type 'ICollection<T, T, T>': setup, unfold\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 126
            },
            "start": {
              "column": 10,
              "line": 120
            }
          }
        },
        {
          "id": "202",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(128,31): error TS2345: Argument of type '{ setup: (x: T) => T; unfold: (acc: T) => void; }' is not assignable to parameter of type 'ICollection<T, T, T>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [T, T] | undefined'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 125
            },
            "start": {
              "column": 31,
              "line": 122
            }
          }
        },
        {
          "id": "203",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected +0 to deeply equal 3",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "30"
          ],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 123
            },
            "start": {
              "column": 11,
              "line": 123
            }
          }
        },
        {
          "id": "204",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "Hit limit reached (701/700)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 123
            },
            "start": {
              "column": 11,
              "line": 123
            }
          }
        },
        {
          "id": "205",
          "mutatorName": "EqualityOperator",
          "replacement": "acc !== id",
          "statusReason": "expected +0 to deeply equal 3",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "30"
          ],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 123
            },
            "start": {
              "column": 11,
              "line": 123
            }
          }
        },
        {
          "id": "206",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(55,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(65,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(75,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(79,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 2,
              "line": 133
            },
            "start": {
              "column": 34,
              "line": 129
            }
          }
        },
        {
          "id": "207",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(55,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(65,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(75,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(79,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "30",
            "32",
            "34",
            "35"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 132
            },
            "start": {
              "column": 29,
              "line": 130
            }
          }
        },
        {
          "id": "208",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.test.ts(51,43): error TS2345: Argument of type '<T>(x: T) => T' is not assignable to parameter of type 'Op<0 | undefined, 0 | undefined, number>'.\n  Call signature return types 'Ctx<0 | undefined, 0 | undefined>' and 'Ctx<0 | undefined, number>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: 0 | undefined, b: 0 | undefined) => 0 | undefined' is not assignable to type '(a: 0 | undefined, b: number) => 0 | undefined'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'number' is not assignable to type '0'.\nsrc/lib/transducers/transformers.test.ts(55,37): error TS2345: Argument of type '<T>(x: T) => T' is not assignable to parameter of type 'Op<0 | undefined, 0 | undefined, number>'.\nsrc/lib/transducers/transformers.test.ts(61,46): error TS2345: Argument of type '<T>(x: T) => T' is not assignable to parameter of type 'Op<0 | undefined, 0 | undefined, number>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 68,
              "line": 135
            },
            "start": {
              "column": 37,
              "line": 135
            }
          }
        },
        {
          "id": "209",
          "mutatorName": "ArithmeticOperator",
          "replacement": "a - b",
          "statusReason": "expected -3 to deeply equal 3",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "29"
          ],
          "coveredBy": [
            "29",
            "30",
            "31"
          ],
          "location": {
            "end": {
              "column": 68,
              "line": 135
            },
            "start": {
              "column": 63,
              "line": 135
            }
          }
        },
        {
          "id": "210",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.test.ts(65,37): error TS2345: Argument of type '<T>(x: T) => T' is not assignable to parameter of type 'Op<1 | undefined, 1 | undefined, number>'.\n  Call signature return types 'Ctx<1 | undefined, 1 | undefined>' and 'Ctx<1 | undefined, number>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: 1 | undefined, b: 1 | undefined) => 1 | undefined' is not assignable to type '(a: 1 | undefined, b: number) => 1 | undefined'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'number' is not assignable to type '1'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 68,
              "line": 137
            },
            "start": {
              "column": 37,
              "line": 137
            }
          }
        },
        {
          "id": "211",
          "mutatorName": "ArithmeticOperator",
          "replacement": "a / b",
          "statusReason": "expected 0.3333333333333333 to deeply equal 3",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "32"
          ],
          "coveredBy": [
            "32"
          ],
          "location": {
            "end": {
              "column": 68,
              "line": 137
            },
            "start": {
              "column": 63,
              "line": 137
            }
          }
        },
        {
          "id": "212",
          "mutatorName": "StringLiteral",
          "replacement": "\"Stryker was here!\"",
          "statusReason": "expected 'Stryker was here!abc' to deeply equal 'abc'",
          "status": "Killed",
          "testsCompleted": 35,
          "static": true,
          "killedBy": [
            "33"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 39,
              "line": 139
            },
            "start": {
              "column": 37,
              "line": 139
            }
          }
        },
        {
          "id": "213",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.test.ts(71,55): error TS2345: Argument of type '<T>(x: T) => T' is not assignable to parameter of type 'Op<\"\" | undefined, \"\" | undefined, string>'.\n  Call signature return types 'Ctx<\"\" | undefined, \"\" | undefined>' and 'Ctx<\"\" | undefined, string>' are incompatible.\n    The types of 'fold' are incompatible between these types.\n      Type '(a: \"\" | undefined, b: \"\" | undefined) => \"\" | undefined' is not assignable to type '(a: \"\" | undefined, b: string) => \"\" | undefined'.\n        Types of parameters 'b' and 'b' are incompatible.\n          Type 'string' is not assignable to type '\"\"'.\nsrc/lib/transducers/transformers.test.ts(75,47): error TS2345: Argument of type '<T>(x: T) => T' is not assignable to parameter of type 'Op<\"\" | undefined, \"\" | undefined, string>'.\n",
          "status": "CompileError",
          "static": true,
          "killedBy": [],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 72,
              "line": 139
            },
            "start": {
              "column": 41,
              "line": 139
            }
          }
        },
        {
          "id": "214",
          "mutatorName": "ArithmeticOperator",
          "replacement": "a - b",
          "statusReason": "src/lib/transducers/transformers.ts(139,41): error TS2345: Argument of type '(a: string, b: string) => number' is not assignable to parameter of type '(a: string, b: string) => string'.\n  Type 'number' is not assignable to type 'string'.\nsrc/lib/transducers/transformers.ts(139,67): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\nsrc/lib/transducers/transformers.ts(139,71): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "33",
            "34"
          ],
          "location": {
            "end": {
              "column": 72,
              "line": 139
            },
            "start": {
              "column": 67,
              "line": 139
            }
          }
        },
        {
          "id": "215",
          "mutatorName": "StringLiteral",
          "replacement": "\"Stryker was here!\"",
          "statusReason": "expected [ '' ] to deeply equal []",
          "status": "Killed",
          "testsCompleted": 37,
          "static": true,
          "killedBy": [
            "35"
          ],
          "coveredBy": [],
          "location": {
            "end": {
              "column": 43,
              "line": 140
            },
            "start": {
              "column": 41,
              "line": 140
            }
          }
        },
        {
          "id": "216",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(145,31): error TS2345: Argument of type 'void' is not assignable to parameter of type 'ICollection<T, T, T>'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 152
            },
            "start": {
              "column": 73,
              "line": 142
            }
          }
        },
        {
          "id": "217",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(147,31): error TS2345: Argument of type '{}' is not assignable to parameter of type 'ICollection<T, T, T>'.\n  Type '{}' is missing the following properties from type 'ICollection<T, T, T>': setup, unfold\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 151
            },
            "start": {
              "column": 10,
              "line": 143
            }
          }
        },
        {
          "id": "218",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.ts(150,31): error TS2345: Argument of type '{ setup: (x: T) => T; unfold: (acc: T) => void; }' is not assignable to parameter of type 'ICollection<T, T, T>'.\n  The types returned by 'unfold(...)' are incompatible between these types.\n    Type 'void' is not assignable to type 'readonly [T, T] | undefined'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 150
            },
            "start": {
              "column": 25,
              "line": 145
            }
          }
        },
        {
          "id": "219",
          "mutatorName": "BooleanLiteral",
          "replacement": "cond(b)",
          "statusReason": "expected [] to deeply equal [ +0, 1, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "36"
          ],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 147
            },
            "start": {
              "column": 11,
              "line": 147
            }
          }
        },
        {
          "id": "220",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ +0, 1, 2 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "36"
          ],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 147
            },
            "start": {
              "column": 11,
              "line": 147
            }
          }
        },
        {
          "id": "221",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "Hit limit reached (1201/1200)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 19,
              "line": 147
            },
            "start": {
              "column": 11,
              "line": 147
            }
          }
        },
        {
          "id": "222",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(85,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(93,11): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(97,19): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(101,19): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 157
            },
            "start": {
              "column": 73,
              "line": 153
            }
          }
        },
        {
          "id": "223",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(85,17): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(93,11): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(97,19): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(101,19): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "36",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 156
            },
            "start": {
              "column": 29,
              "line": 154
            }
          }
        },
        {
          "id": "224",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/transformers.test.ts(93,11): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(97,19): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/transformers.test.ts(101,19): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "37",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 164
            },
            "start": {
              "column": 53,
              "line": 159
            }
          }
        },
        {
          "id": "225",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "step cannot be 0",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "38"
          ],
          "coveredBy": [
            "37",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 160
            },
            "start": {
              "column": 7,
              "line": 160
            }
          }
        },
        {
          "id": "226",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "37"
          ],
          "coveredBy": [
            "37",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 160
            },
            "start": {
              "column": 7,
              "line": 160
            }
          }
        },
        {
          "id": "227",
          "mutatorName": "EqualityOperator",
          "replacement": "step !== 0",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "37"
          ],
          "coveredBy": [
            "37",
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 17,
              "line": 160
            },
            "start": {
              "column": 7,
              "line": 160
            }
          }
        },
        {
          "id": "228",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "expected [Function] to throw error including 'step cannot be 0' but got ''",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "37"
          ],
          "coveredBy": [
            "37"
          ],
          "location": {
            "end": {
              "column": 53,
              "line": 160
            },
            "start": {
              "column": 35,
              "line": 160
            }
          }
        },
        {
          "id": "229",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [] to deeply equal [ +0, -2, -4 ]",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "39"
          ],
          "coveredBy": [
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 162
            },
            "start": {
              "column": 16,
              "line": 162
            }
          }
        },
        {
          "id": "230",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ +0, 2, 4 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "38"
          ],
          "coveredBy": [
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 24,
              "line": 162
            },
            "start": {
              "column": 16,
              "line": 162
            }
          }
        },
        {
          "id": "231",
          "mutatorName": "EqualityOperator",
          "replacement": "step >= 0",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 24,
              "line": 162
            },
            "start": {
              "column": 16,
              "line": 162
            }
          }
        },
        {
          "id": "232",
          "mutatorName": "EqualityOperator",
          "replacement": "step <= 0",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 24,
              "line": 162
            },
            "start": {
              "column": 16,
              "line": 162
            }
          }
        },
        {
          "id": "233",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(163,19): error TS2345: Argument of type '(() => undefined) | ((v: number) => boolean)' is not assignable to parameter of type '(b: number) => boolean'.\n  Type '() => undefined' is not assignable to type '(b: number) => boolean'.\n    Type 'undefined' is not assignable to type 'boolean'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "38"
          ],
          "location": {
            "end": {
              "column": 49,
              "line": 162
            },
            "start": {
              "column": 27,
              "line": 162
            }
          }
        },
        {
          "id": "234",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "Hit limit reached (401/400)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "38"
          ],
          "location": {
            "end": {
              "column": 49,
              "line": 162
            },
            "start": {
              "column": 42,
              "line": 162
            }
          }
        },
        {
          "id": "235",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ +0, 2, 4 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "38"
          ],
          "coveredBy": [
            "38"
          ],
          "location": {
            "end": {
              "column": 49,
              "line": 162
            },
            "start": {
              "column": 42,
              "line": 162
            }
          }
        },
        {
          "id": "236",
          "mutatorName": "EqualityOperator",
          "replacement": "v < to",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 49,
              "line": 162
            },
            "start": {
              "column": 42,
              "line": 162
            }
          }
        },
        {
          "id": "237",
          "mutatorName": "EqualityOperator",
          "replacement": "v > to",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 49,
              "line": 162
            },
            "start": {
              "column": 42,
              "line": 162
            }
          }
        },
        {
          "id": "238",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(163,19): error TS2345: Argument of type '((v: number) => boolean) | (() => undefined)' is not assignable to parameter of type '(b: number) => boolean'.\n  Type '() => undefined' is not assignable to type '(b: number) => boolean'.\n    Type 'undefined' is not assignable to type 'boolean'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "39"
          ],
          "location": {
            "end": {
              "column": 74,
              "line": 162
            },
            "start": {
              "column": 52,
              "line": 162
            }
          }
        },
        {
          "id": "239",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "Hit limit reached (401/400)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "39"
          ],
          "location": {
            "end": {
              "column": 74,
              "line": 162
            },
            "start": {
              "column": 67,
              "line": 162
            }
          }
        },
        {
          "id": "240",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [] to deeply equal [ +0, -2, -4 ]",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "39"
          ],
          "coveredBy": [
            "39"
          ],
          "location": {
            "end": {
              "column": 74,
              "line": 162
            },
            "start": {
              "column": 67,
              "line": 162
            }
          }
        },
        {
          "id": "241",
          "mutatorName": "EqualityOperator",
          "replacement": "v > to",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 74,
              "line": 162
            },
            "start": {
              "column": 67,
              "line": 162
            }
          }
        },
        {
          "id": "242",
          "mutatorName": "EqualityOperator",
          "replacement": "v < to",
          "statusReason": "Ignored using a comment",
          "status": "Ignored",
          "static": false,
          "location": {
            "end": {
              "column": 74,
              "line": 162
            },
            "start": {
              "column": 67,
              "line": 162
            }
          }
        },
        {
          "id": "243",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "src/lib/transducers/transformers.ts(163,31): error TS2322: Type 'undefined' is not assignable to type 'number'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 40,
              "line": 163
            },
            "start": {
              "column": 25,
              "line": 163
            }
          }
        },
        {
          "id": "244",
          "mutatorName": "ArithmeticOperator",
          "replacement": "v - step",
          "statusReason": "Hit limit reached (601/600)",
          "status": "Timeout",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "38",
            "39"
          ],
          "location": {
            "end": {
              "column": 40,
              "line": 163
            },
            "start": {
              "column": 32,
              "line": 163
            }
          }
        }
      ],
      "source": "import { transduce } from \"./core\";\n\nexport const nop = () => {};\nexport const identity = <T>(x: T) => x;\nexport const constant =\n  <T>(x: T) =>\n  () =>\n    x;\n\n// TODO: curriend versions (form*)\n// TODO: matchAll, RegExp.prototype[@@matchAll]()\n\nexport interface IXForm<A, B, C> {\n  init: () => A;\n  fold: (a: A, b: B) => A;\n  result: (a: A) => C;\n}\n\nexport interface ICollection<P, Q, B> {\n  setup: (a: Q) => P;\n  unfold: (unacc: P) => readonly [P, B] | undefined;\n}\n\nexport function toLast<T>() {\n  return {\n    init: constant(undefined),\n    fold: (_acc: T | undefined, b: T) => b,\n    result: identity,\n  };\n}\n\nexport function forEach<T>(cb: (a: T) => void) {\n  return {\n    init: constant(cb),\n    fold: (acc: (a: T) => void, b: T) => {\n      acc(b);\n      return acc;\n    },\n    result: nop,\n  };\n}\n\nfunction getIter<T>(iterable: Iterable<T>) {\n  const obj = iterable[Symbol.iterator]();\n  return () => obj.next();\n}\n\nexport function iterColl<T>() {\n  const coll = {\n    setup: getIter<T>,\n    unfold: function (next: () => IteratorResult<T, any>) {\n      const { value, done } = next();\n      if (done) return undefined;\n      return [next, value] as const;\n    },\n  };\n  return coll;\n}\n\nexport function fromIter<T>(init: Iterable<T>) {\n  return transduce<() => IteratorResult<T, any>, Iterable<T>, T>(\n    iterColl(),\n    init,\n  );\n}\n\nexport function toMap<K, V>() {\n  return {\n    init: () => new Map<K, V>(),\n    fold: function (acc: Map<K, V>, [k, v]: [K, V]) {\n      acc.set(k, v);\n      return acc;\n    },\n    result: identity<Map<K, V>>,\n  };\n}\n\nexport function toArray<B>() {\n  return {\n    init: () => [] as B[],\n    fold: function (acc: B[], b: B) {\n      acc.push(b);\n      return acc;\n    },\n    result: identity<B[]>,\n  };\n}\n\nexport function arrayColl<T>(): ICollection<T[], T[], T> {\n  const coll = {\n    setup: identity<T[]>,\n    unfold: function (xs: T[]) {\n      const x = xs.shift();\n      if (x === undefined) {\n        return undefined;\n      }\n      return [xs, x as T] as const;\n    },\n  };\n  return coll;\n}\n\nexport function fromArray<T>(init: T[]) {\n  return transduce<T[], T[], T>(arrayColl(), init);\n}\n\n// this makes sense for any group\nfunction toOpFactory<T>(id: T, op: (a: T, b: T) => T) {\n  return function () {\n    return {\n      init: constant(id),\n      fold: op,\n      result: identity,\n    };\n  };\n}\n\n// for the sake of respecting the identity law\nfunction opCollFactory<T>(id: T) {\n  return {\n    setup: identity<T>,\n    unfold: function (acc: T) {\n      if (acc === id) return undefined;\n      return [id, acc] as const;\n    },\n  };\n}\n\nfunction fromOpFactory<T>(id: T) {\n  return function (init: T) {\n    return transduce<T, T, T>(opCollFactory(id), init);\n  };\n}\n\nexport const toSum = toOpFactory(0, (a: number, b: number) => a + b);\nexport const fromSum = fromOpFactory(0);\nexport const toMul = toOpFactory(1, (a: number, b: number) => a * b);\nexport const fromMul = fromOpFactory(1);\nexport const toConcat = toOpFactory(\"\", (a: string, b: string) => a + b);\nexport const fromConcat = fromOpFactory(\"\");\n\nexport function loopColl<T>(cond: (b: T) => boolean, step: (b: T) => T) {\n  return {\n    setup: identity<T>,\n    unfold: (acc: T) => {\n      const b = acc;\n      if (!cond(b)) return undefined;\n      acc = step(acc);\n      return [acc, b] as const;\n    },\n  };\n}\nexport function fromLoop<T>(cond: (b: T) => boolean, step: (b: T) => T) {\n  return function (init: T) {\n    return transduce<T, T, T>(loopColl(cond, step), init);\n  };\n}\n\nexport function fromRange(to: number, step: number) {\n  if (step === 0) throw new Error(\"step cannot be 0\");\n  // Stryker disable next-line EqualityOperator\n  const cond = step > 0 ? (v: number) => v <= to : (v: number) => v >= to;\n  return fromLoop(cond, (v) => v + step);\n}\n"
    },
    "src/lib/transducers/utils.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "245",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.test.ts(38,23): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\nsrc/lib/transducers/reducers.test.ts(45,28): error TS18046: 'x' is of type 'unknown'.\nsrc/lib/transducers/utils.test.ts(11,23): error TS2349: This expression is not callable.\n  Type 'void' has no call signatures.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "42"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 18
            },
            "start": {
              "column": 3,
              "line": 8
            }
          }
        },
        {
          "id": "246",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.test.ts(38,23): error TS2488: Type 'void' must have a '[Symbol.iterator]()' method that returns an iterator.\nsrc/lib/transducers/utils.test.ts(11,23): error TS2488: Type 'void' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "42"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 17
            },
            "start": {
              "column": 42,
              "line": 9
            }
          }
        },
        {
          "id": "247",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.test.ts(38,23): error TS2488: Type '{}' must have a '[Symbol.iterator]()' method that returns an iterator.\nsrc/lib/transducers/utils.test.ts(11,23): error TS2488: Type '{}' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "42"
          ],
          "location": {
            "end": {
              "column": 6,
              "line": 16
            },
            "start": {
              "column": 12,
              "line": 11
            }
          }
        },
        {
          "id": "248",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/lib/transducers/reducers.test.ts(38,23): error TS2488: Type '{ next: () => IteratorResult<[number, number], any>; [Symbol.iterator](): void; }' must have a '[Symbol.iterator]()' method that returns an iterator.\nsrc/lib/transducers/utils.test.ts(11,23): error TS2488: Type '{ next: () => IteratorResult<number, any>; [Symbol.iterator](): void; }' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "1",
            "42"
          ],
          "location": {
            "end": {
              "column": 8,
              "line": 15
            },
            "start": {
              "column": 27,
              "line": 13
            }
          }
        }
      ],
      "source": "import { step } from \"./core\";\nimport { Op } from \"./reducers\";\nimport { ICollection } from \"./transformers\";\n\nexport function transformIterator<N, P, Q>(\n  coll: ICollection<P, Q, N>,\n  init: Q,\n) {\n  return function <B>(op: Op<B[], B, N>) {\n    const next = step<B, N, P, Q>(op, init, coll);\n    return {\n      next,\n      [Symbol.iterator]() {\n        return this;\n      },\n    };\n  };\n}\n"
    }
  },
  "schemaVersion": "1.0",
  "thresholds": {
    "high": 80,
    "low": 60,
    "break": null
  },
  "testFiles": {
    "src/lib/transducers/reducers.test.ts": {
      "tests": [
        {
          "id": "0",
          "name": "reducers errors shoud rethrow an error (core/transform)"
        },
        {
          "id": "1",
          "name": "reducers errors shoud rethrow an error (core/step)"
        },
        {
          "id": "2",
          "name": "reducers map should map with a type change"
        },
        {
          "id": "3",
          "name": "reducers take should take a kayak (and a chair)"
        },
        {
          "id": "4",
          "name": "reducers find should return all results up to seek target"
        },
        {
          "id": "5",
          "name": "reducers drop should drop a kayak"
        },
        {
          "id": "6",
          "name": "reducers takeWhile should take while cond is true"
        },
        {
          "id": "7",
          "name": "reducers dropWhile should drop while cond is true"
        },
        {
          "id": "8",
          "name": "reducers uniq should remove consecutive duplicates"
        },
        {
          "id": "9",
          "name": "reducers uniq should treat undefined as any other value"
        },
        {
          "id": "10",
          "name": "reducers filter should keep values satisfying predicate"
        },
        {
          "id": "11",
          "name": "reducers replace should replace values satisfying predicate"
        },
        {
          "id": "12",
          "name": "reducers apertures should return sliding windows of length n"
        },
        {
          "id": "13",
          "name": "reducers slices should return consecutive slices of length n, leaving out extra values"
        },
        {
          "id": "14",
          "name": "reducers fold should replace list with folded values"
        },
        {
          "id": "15",
          "name": "reducers map should map values with function"
        },
        {
          "id": "16",
          "name": "reducers flatten should flatten once"
        },
        {
          "id": "17",
          "name": "reducers flatten should flatten twice"
        },
        {
          "id": "18",
          "name": "reducers flatten should flatten then map"
        },
        {
          "id": "19",
          "name": "reducers chain should flatten a structure using chain"
        },
        {
          "id": "20",
          "name": "reducers chain should flatten a structure using map then flatten"
        },
        {
          "id": "21",
          "name": "reducers zip should zip (transpose) two structures"
        },
        {
          "id": "22",
          "name": "reducers zip should truncate when first sequence is shorter"
        },
        {
          "id": "23",
          "name": "reducers zip should truncate when second sequence is shorter"
        },
        {
          "id": "24",
          "name": "reducers zip should zip and take"
        },
        {
          "id": "25",
          "name": "reducers zip should zip and take while"
        }
      ],
      "source": "import { pipe } from \"ramda\";\nimport {\n  apertures,\n  drop,\n  dropWhile,\n  filter,\n  fold,\n  map,\n  replace,\n  slices,\n  take,\n  takeWhile,\n  uniq,\n  zip,\n  flatten,\n  chain,\n  find,\n} from \"./reducers\";\nimport { toArray, fromIter, iterColl } from \"./transformers\";\nimport { transformIterator } from \"./utils\";\n\nconst mul = (x: number) => (y: number) => x * y;\nconst odd = (x: number) => x % 2 === 1;\n\ndescribe(\"reducers\", () => {\n  describe(\"errors\", () => {\n    const fail = (i: number): number => {\n      if (i === 5) throw \"failure\";\n      return i;\n    };\n    it(\"shoud rethrow an error (core/transform)\", () => {\n      expect(() => {\n        fromIter([4, 5, 6])(toArray<number>(), map(fail));\n      }).toThrowError(\"failure\");\n    });\n    it(\"shoud rethrow an error (core/step)\", () => {\n      const xs: [number, number][] = [];\n      for (const x of transformIterator(\n        iterColl<number>(),\n        [1, 2, 3],\n      )<[number, number]>(\n        zip(\n          iterColl(),\n          [4, 5, 6],\n          takeWhile((x) => x < 5),\n        ),\n      )) {\n        xs.push(x);\n      }\n      expect(xs).toEqual([[1, 4]]);\n    });\n    it(\"shoud rethrow an error (core/step)\", () => {\n      expect(() => {\n        fromIter([1, 2, 3])(\n          toArray<[number, number]>(),\n          zip(iterColl(), [4, 5, 6], map(fail)),\n        );\n      }).toThrowError(\"failure\");\n    });\n  });\n  describe(\"map\", () => {\n    test(\"should map with a type change\", () => {\n      const toAs = (x: number) => {\n        let s = \"\";\n        while (x > 0) {\n          x--;\n          s += \"a\";\n        }\n        return s;\n      };\n      const xs = fromIter([1, 2, 3])(toArray<string>(), map(toAs));\n      expect(xs).toEqual([\"a\", \"aa\", \"aaa\"]);\n    });\n  });\n  describe(\"take\", () => {\n    const xs = fromIter([\"kayak\", \"chair\", \"goat\"])(toArray<string>(), take(2));\n    it(\"should take a kayak (and a chair)\", () => {\n      expect(xs).toEqual([\"kayak\", \"chair\"]);\n    });\n  });\n  describe(\"find\", () => {\n    const xs = fromIter([\"kayak\", \"chair\", \"goat\"])(\n      toArray<string>(),\n      find((x: string) => x === \"chair\"),\n    );\n    it(\"should return all results up to seek target\", () => {\n      expect(xs).toEqual([\"kayak\", \"chair\"]);\n    });\n  });\n  describe(\"drop\", () => {\n    const xs = fromIter([\"kayak\", \"chair\", \"goat\"])(toArray<string>(), drop(1));\n    it(\"should drop a kayak\", () => {\n      expect(xs).toEqual([\"chair\", \"goat\"]);\n    });\n  });\n  describe(\"takeWhile\", () => {\n    it(\"should take while cond is true\", () => {\n      const xs = fromIter([1, 3, 4, 5])(toArray<number>(), takeWhile(odd));\n      expect(xs).toEqual([1, 3]);\n    });\n  });\n  describe(\"dropWhile\", () => {\n    it(\"should drop while cond is true\", () => {\n      const xs = fromIter([1, 3, 4, 5])(toArray<number>(), dropWhile(odd));\n      expect(xs).toEqual([4, 5]);\n    });\n  });\n  describe(\"uniq\", () => {\n    it(\"should remove consecutive duplicates\", () => {\n      const xs = fromIter([1, 1, 2, 3, 2])(toArray<number>(), uniq());\n      expect(xs).toEqual([1, 2, 3, 2]);\n    });\n    it(\"should treat undefined as any other value\", () => {\n      const xs = fromIter([undefined, 1, 1, undefined, undefined, 3, 1, 3])(\n        toArray<number | undefined>(),\n        uniq(),\n      );\n      expect(xs).toEqual([undefined, 1, undefined, 3, 1, 3]);\n    });\n  });\n  describe(\"filter\", () => {\n    const xs = fromIter([1, 2, 3])(toArray<number>(), filter(odd));\n    it(\"should keep values satisfying predicate\", () => {\n      expect(xs).toEqual([1, 3]);\n    });\n  });\n  describe(\"replace\", () => {\n    const xs = fromIter([2, 3, 4])(\n      toArray<number>(),\n      replace(odd, 2 as number),\n    );\n    it(\"should replace values satisfying predicate\", () => {\n      expect(xs).toEqual([2, 2, 4]);\n    });\n  });\n  describe(\"apertures\", () => {\n    const xs = fromIter([1, 2, 3])(toArray<number[]>(), apertures(2));\n    it(\"should return sliding windows of length n\", () => {\n      expect(xs).toEqual([\n        [1, 2],\n        [2, 3],\n      ]);\n    });\n  });\n  describe(\"slices\", () => {\n    it(\"should return consecutive slices of length n, leaving out extra values\", () => {\n      const xs = fromIter([1, 2, 3, 4, 5])(toArray<number[]>(), slices(2));\n      expect(xs).toEqual([\n        [1, 2],\n        [3, 4],\n      ]);\n    });\n  });\n  describe(\"fold\", () => {\n    it(\"should replace list with folded values\", () => {\n      const xs = fromIter([1, 2, 3])(\n        toArray<number>(),\n        fold((a: number, b: number) => a + b, 1),\n      );\n      expect(xs).toEqual([2, 4, 7]);\n    });\n  });\n  describe(\"map\", () => {\n    it(\"should map values with function\", () => {\n      const f = (x: number) => x * 2;\n      const xs = fromIter([1, 2, 3])(toArray<number>(), map(f));\n      expect(xs).toEqual([2, 4, 6]);\n    });\n  });\n  describe(\"flatten\", () => {\n    it(\"should flatten once\", () => {\n      const xs = fromIter([\n        [1, 2, 3],\n        [4, 5],\n      ])(toArray<number>(), flatten(iterColl(), map(mul(2))));\n      expect(xs).toEqual([2, 4, 6, 8, 10]);\n    });\n    it(\"should flatten twice\", () => {\n      const xs = fromIter([[[1, 2, 3]]])(\n        toArray<number>(),\n        pipe(flatten(iterColl()), flatten(iterColl())),\n      );\n      expect(xs).toEqual([1, 2, 3]);\n    });\n    it(\"should flatten then map\", () => {\n      const xs = fromIter([[1, 2, 3]])(\n        toArray<number>(),\n        pipe(map(mul(2)), flatten(iterColl())),\n      );\n      expect(xs).toEqual([2, 4, 6]);\n    });\n  });\n  describe(\"chain\", () => {\n    describe(\"should flatten a structure\", () => {\n      function ar(n: number) {\n        const a = [];\n        for (let i = 0; i < n; i++) {\n          a.push(i);\n        }\n        return a;\n      }\n      it(\"using chain\", () => {\n        const xs = fromIter([1, 2, 3])(\n          toArray<number>(),\n          chain(iterColl(), ar),\n        );\n        expect(xs).toEqual([0, 0, 1, 0, 1, 2]);\n      });\n      it(\"using map then flatten\", () => {\n        const xs = fromIter([1, 2, 3])(\n          toArray<number>(),\n          pipe(flatten(iterColl()), map(ar)),\n        );\n        expect(xs).toEqual([0, 0, 1, 0, 1, 2]);\n      });\n    });\n  });\n\n  describe(\"zip\", () => {\n    it(\"should zip (transpose) two structures\", () => {\n      const xs = fromIter([1, 2, 3])(\n        toArray<[number, number]>(),\n        zip(iterColl(), [4, 5, 6]),\n      );\n      expect(xs).toEqual([\n        [1, 4],\n        [2, 5],\n        [3, 6],\n      ]);\n    });\n    it(\"should truncate when first sequence is shorter\", () => {\n      const xs = fromIter([1, 2])(\n        toArray<[number, number]>(),\n        zip(iterColl(), [4, 5, 6]),\n      );\n      expect(xs).toEqual([\n        [1, 4],\n        [2, 5],\n      ]);\n    });\n    it(\"should truncate when second sequence is shorter\", () => {\n      const xs = fromIter([1, 2, 3])(\n        toArray<[number, number]>(),\n        zip(iterColl(), [4, 5]),\n      );\n      expect(xs).toEqual([\n        [1, 4],\n        [2, 5],\n      ]);\n    });\n    it(\"should zip and take\", () => {\n      const xs = fromIter([1, 2, 3])(\n        toArray<[number, number]>(),\n        zip(iterColl(), [4, 5, 6], take(1)),\n      );\n      expect(xs).toEqual([[1, 4]]);\n    });\n    it(\"should zip and take while\", () => {\n      const xs = fromIter([1, 2, 3])(\n        toArray<[number, number]>(),\n        zip(\n          iterColl(),\n          [4, 5, 6],\n          takeWhile((x: number) => x < 5),\n        ),\n      );\n      expect(xs).toEqual([[1, 4]]);\n    });\n  });\n});\n"
    },
    "src/lib/transducers/transformers.test.ts": {
      "tests": [
        {
          "id": "26",
          "name": "reducers fromIter should respect the identity law"
        },
        {
          "id": "27",
          "name": "reducers mapForm should respect the identity law"
        },
        {
          "id": "28",
          "name": "reducers last should return the last value"
        },
        {
          "id": "29",
          "name": "reducers sumForm should return the sum of elements"
        },
        {
          "id": "30",
          "name": "reducers sumForm should respect identity law"
        },
        {
          "id": "31",
          "name": "reducers mulForm should return the product of elements"
        },
        {
          "id": "32",
          "name": "reducers mulForm should respect identity law"
        },
        {
          "id": "33",
          "name": "reducers concatForm should return the concatenation of elements"
        },
        {
          "id": "34",
          "name": "reducers concatForm should respect identity law"
        },
        {
          "id": "35",
          "name": "reducers concatForm should have zero element"
        },
        {
          "id": "36",
          "name": "reducers loopForm should loop from value applying step until condition is met"
        },
        {
          "id": "37",
          "name": "reducers rangeForm should produce the elements up to value by increment should not have step 0"
        },
        {
          "id": "38",
          "name": "reducers rangeForm should produce the elements up to value by increment ascending"
        },
        {
          "id": "39",
          "name": "reducers rangeForm should produce the elements up to value by increment descending"
        },
        {
          "id": "40",
          "name": "reducers map should map values with function"
        },
        {
          "id": "41",
          "name": "reducers forEach should call callback for each occurence"
        }
      ],
      "source": "import {\n  forEach,\n  fromArray,\n  fromConcat,\n  fromIter,\n  fromLoop,\n  fromMul,\n  fromRange,\n  fromSum,\n  toArray,\n  toConcat,\n  toLast,\n  toMap,\n  toMul,\n  toSum,\n} from \"./transformers\";\nimport { map } from \"./reducers\";\n\nconst identity = <T>(x: T) => x;\nconst add = (x: number) => (y: number) => x + y;\n\ndescribe(\"reducers\", () => {\n  describe(\"fromIter\", () => {\n    it(\"should respect the identity law\", () => {\n      const xs = fromIter([1, 2, 3])(toArray<number>(), identity);\n      expect(xs).toEqual([1, 2, 3]);\n    });\n  });\n  describe(\"mapForm\", () => {\n    const xs = fromIter(\n      new Map([\n        [1, 2],\n        [3, 4],\n      ]),\n    )(toMap<number, number>(), identity);\n    it(\"should respect the identity law\", () => {\n      expect(Array.from(xs.entries())).toEqual([\n        [1, 2],\n        [3, 4],\n      ]);\n    });\n  });\n  describe(\"last\", () => {\n    it(\"should return the last value\", () => {\n      const x = fromIter([1, 2, 3])(toLast<number>(), identity);\n      expect(x).toEqual(3);\n    });\n  });\n  describe(\"sumForm\", () => {\n    it(\"should return the sum of elements\", () => {\n      const x = fromIter([1, 2])(toSum(), identity);\n      expect(x).toEqual(3);\n    });\n    it(\"should respect identity law\", () => {\n      const x = fromSum(3)(toSum(), identity);\n      expect(x).toEqual(3);\n    });\n  });\n  describe(\"mulForm\", () => {\n    it(\"should return the product of elements\", () => {\n      const x = fromIter([1, 2, 3])(toSum(), identity);\n      expect(x).toEqual(6);\n    });\n    it(\"should respect identity law\", () => {\n      const x = fromMul(3)(toMul(), identity);\n      expect(x).toEqual(3);\n    });\n  });\n  describe(\"concatForm\", () => {\n    it(\"should return the concatenation of elements\", () => {\n      const x = fromIter([\"a\", \"b\", \"c\"])(toConcat(), identity);\n      expect(x).toEqual(\"abc\");\n    });\n    it(\"should respect identity law\", () => {\n      const x = fromConcat(\"abc\")(toConcat(), identity);\n      expect(x).toEqual(\"abc\");\n    });\n    it(\"should have zero element\", () => {\n      const x = fromConcat(\"\")(toArray(), identity);\n      expect(x).toEqual([]);\n    });\n  });\n  describe(\"loopForm\", () => {\n    it(\"should loop from value applying step until condition is met\", () => {\n      const x = fromLoop((x) => x < 3, add(1))(0)(toArray<number>(), identity);\n      expect(x).toEqual([0, 1, 2]);\n    });\n  });\n  describe(\"rangeForm\", () => {\n    describe(\"should produce the elements up to value by increment\", () => {\n      it(\"should not have step 0\", () => {\n        expect(() => {\n          fromRange(4, 0)(0)(toArray<number>(), identity);\n        }).toThrowError(\"step cannot be 0\");\n      });\n      it(\"ascending\", () => {\n        const x = fromRange(4, 2)(0)(toArray<number>(), identity);\n        expect(x).toEqual([0, 2, 4]);\n      });\n      it(\"descending\", () => {\n        const x = fromRange(-4, -2)(0)(toArray<number>(), identity);\n        expect(x).toEqual([0, -2, -4]);\n      });\n    });\n  });\n  describe(\"map\", () => {\n    it(\"should map values with function\", () => {\n      const f = (x: number) => x * 2;\n      const xs = fromArray([1, 2, 3])(toArray<number>(), map(f));\n      expect(xs).toEqual([2, 4, 6]);\n    });\n  });\n  describe(\"forEach\", () => {\n    it(\"should call callback for each occurence\", () => {\n      let i = 0;\n      const f = (x: number) => x * 2;\n      fromIter([1, 2, 3])(\n        forEach<number>((x: number) => (i += x)),\n        map(f),\n      );\n\n      expect(i).toEqual(12);\n    });\n  });\n});\n"
    },
    "src/lib/transducers/utils.test.ts": {
      "tests": [
        {
          "id": "42",
          "name": "utils transformIterator should iterate"
        }
      ],
      "source": "import { map } from \"./reducers\";\nimport { iterColl } from \"./transformers\";\nimport { transformIterator } from \"./utils\";\n\nconst mul = (x: number) => (y: number) => x * y;\n\ndescribe(\"utils\", () => {\n  describe(\"transformIterator\", () => {\n    it(\"should iterate\", () => {\n      const xs: number[] = [];\n      for (const x of transformIterator(\n        iterColl<number>(),\n        [1, 2, 3],\n      )<number>(map(mul(2)))) {\n        xs.push(x);\n      }\n      expect(xs).toEqual([2, 4, 6]);\n    });\n  });\n});\n"
    }
  },
  "projectRoot": "/home/prncss/Projects/github.com/prncss-xyz/beam/packages/beam",
  "config": {
    "_comment": "This config was generated using 'stryker init'. Please take a look at: https://stryker-mutator.io/docs/stryker-js/configuration/ for more information.",
    "packageManager": "pnpm",
    "reporters": [
      "html",
      "clear-text",
      "progress"
    ],
    "testRunner": "vitest",
    "ignorePatterns": [
      "coverage",
      "dist"
    ],
    "incremental": true,
    "ignoreStatic": false,
    "testRunner_comment": "Take a look at (missing 'homepage' URL in package.json) for information about the vitest plugin.",
    "coverageAnalysis": "perTest",
    "plugins": [
      "@stryker-mutator/vitest-runner",
      "@stryker-mutator/typescript-checker"
    ],
    "checkers": [
      "typescript"
    ],
    "tsconfigFile": "tsconfig.json",
    "typescriptChecker": {
      "prioritizePerformanceOverAccuracy": true
    },
    "allowConsoleColors": true,
    "checkerNodeArgs": [],
    "commandRunner": {
      "command": "npm test"
    },
    "clearTextReporter": {
      "allowColor": true,
      "allowEmojis": false,
      "logTests": true,
      "maxTestsToLog": 3,
      "reportTests": true,
      "reportMutants": true,
      "reportScoreTable": true
    },
    "dashboard": {
      "baseUrl": "https://dashboard.stryker-mutator.io/api/reports",
      "reportType": "full"
    },
    "dryRunOnly": false,
    "eventReporter": {
      "baseDir": "reports/mutation/events"
    },
    "incrementalFile": "reports/stryker-incremental.json",
    "force": false,
    "fileLogLevel": "off",
    "inPlace": false,
    "logLevel": "info",
    "maxConcurrentTestRunners": 9007199254740991,
    "maxTestRunnerReuse": 0,
    "mutate": [
      "{src,lib}/**/!(*.+(s|S)pec|*.+(t|T)est).+(cjs|mjs|js|ts|jsx|tsx|html|vue|svelte)",
      "!{src,lib}/**/__tests__/**/*.+(cjs|mjs|js|ts|jsx|tsx|html|vue|svelte)"
    ],
    "mutator": {
      "plugins": null,
      "excludedMutations": []
    },
    "appendPlugins": [],
    "htmlReporter": {
      "fileName": "reports/mutation/mutation.html"
    },
    "jsonReporter": {
      "fileName": "reports/mutation/mutation.json"
    },
    "disableTypeChecks": true,
    "symlinkNodeModules": true,
    "tempDirName": ".stryker-tmp",
    "cleanTempDir": true,
    "testRunnerNodeArgs": [],
    "thresholds": {
      "high": 80,
      "low": 60,
      "break": null
    },
    "timeoutFactor": 1.5,
    "timeoutMS": 5000,
    "dryRunTimeoutMinutes": 5,
    "warnings": true,
    "disableBail": false,
    "allowEmpty": false,
    "ignorers": [],
    "vitest": {}
  },
  "framework": {
    "name": "StrykerJS",
    "version": "8.0.0",
    "branding": {
      "homepageUrl": "https://stryker-mutator.io",
      "imageUrl": "data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"
    },
    "dependencies": {
      "@stryker-mutator/typescript-checker": "8.0.0",
      "typescript": "5.3.3"
    }
  }
}